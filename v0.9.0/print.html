<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>PyO3 user guide</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="PyO3 user guide">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div id="sidebar-scrollbox" class="sidebar-scrollbox">
                <ol class="chapter"><li class="expanded "><a href="get_started.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li class="expanded "><a href="module.html"><strong aria-hidden="true">2.</strong> Python Modules</a></li><li class="expanded "><a href="function.html"><strong aria-hidden="true">3.</strong> Python Functions</a></li><li class="expanded "><a href="class.html"><strong aria-hidden="true">4.</strong> Python Classes</a></li><li class="expanded "><a href="conversions.html"><strong aria-hidden="true">5.</strong> Type Conversions</a></li><li class="expanded "><a href="exception.html"><strong aria-hidden="true">6.</strong> Python Exceptions</a></li><li class="expanded "><a href="python_from_rust.html"><strong aria-hidden="true">7.</strong> Calling Python from Rust</a></li><li class="expanded "><a href="types.html"><strong aria-hidden="true">8.</strong> GIL, mutability and object types</a></li><li class="expanded "><a href="parallelism.html"><strong aria-hidden="true">9.</strong> Parallelism</a></li><li class="expanded "><a href="debugging.html"><strong aria-hidden="true">10.</strong> Debugging</a></li><li class="expanded "><a href="advanced.html"><strong aria-hidden="true">11.</strong> Advanced Topics</a></li><li class="expanded "><a href="building_and_distribution.html"><strong aria-hidden="true">12.</strong> Building and Distribution</a></li><li class="expanded "><a href="pypy.html"><strong aria-hidden="true">13.</strong> PyPy support</a></li><li class="expanded "><a href="rust_cpython.html"><strong aria-hidden="true">14.</strong> Appendix A: PyO3 and rust-cpython</a></li><li class="expanded "><a href="migration.html"><strong aria-hidden="true">15.</strong> Appendix B: Migration Guide</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">PyO3 user guide</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#pyo3" id="pyo3">PyO3</a></h1>
<p><a href="http://www.rust-lang.org/">Rust</a> bindings for <a href="https://www.python.org/">Python</a>. This includes running and interacting with Python code from a Rust binary, as well as writing native Python modules.</p>
<ul>
<li>
<p>User Guide: <a href="https://pyo3.rs">stable</a> | <a href="https://pyo3.rs/master">master</a></p>
</li>
<li>
<p>API Documentation: <a href="https://pyo3.rs/master/doc">master</a></p>
</li>
</ul>
<p>A comparison with rust-cpython can be found <a href="https://pyo3.rs/master/rust_cpython.html">in the guide</a>.</p>
<h2><a class="header" href="#usage" id="usage">Usage</a></h2>
<p>PyO3 supports Python 3.5 and up. The minimum required Rust version is 1.42.0-nightly 2019-01-21.</p>
<p>If you have never used nightly Rust, the official guide has
<a href="https://doc.rust-lang.org/book/appendix-07-nightly-rust.html#rustup-and-the-role-of-rust-nightly">a great section</a>
about installing it.</p>
<p>PyPy is also supported (via cpyext) for Python 3.5 only, targeted PyPy version is 7.0.0.
Please refer to the <a href="https://pyo3.rs/master/pypy.html">pypy section</a>.</p>
<p>You can either write a native Python module in Rust, or use Python from a Rust binary.</p>
<p>However, on some OSs, you need some additional packages. E.g. if you are on <em>Ubuntu 18.04</em>, please run</p>
<pre><code class="language-bash">sudo apt install python3-dev python-dev
</code></pre>
<h2><a class="header" href="#using-rust-from-python" id="using-rust-from-python">Using Rust from Python</a></h2>
<p>PyO3 can be used to generate a native Python module.</p>
<p><strong><code>Cargo.toml</code></strong></p>
<pre><code class="language-toml">[package]
name = &quot;string-sum&quot;
version = &quot;0.1.0&quot;
edition = &quot;2018&quot;

[lib]
name = &quot;string_sum&quot;
crate-type = [&quot;cdylib&quot;]

[dependencies.pyo3]
version = &quot;0.9.0&quot;
features = [&quot;extension-module&quot;]
</code></pre>
<p><strong><code>src/lib.rs</code></strong></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;
use pyo3::wrap_pyfunction;

#[pyfunction]
/// Formats the sum of two numbers as string.
fn sum_as_string(a: usize, b: usize) -&gt; PyResult&lt;String&gt; {
    Ok((a + b).to_string())
}

#[pymodule]
/// A Python module implemented in Rust.
fn string_sum(py: Python, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; {
    m.add_wrapped(wrap_pyfunction!(sum_as_string))?;

    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p>On Windows and Linux, you can build normally with <code>cargo build --release</code>. On macOS, you need to set additional linker arguments. One option is to compile with <code>cargo rustc --release -- -C link-arg=-undefined -C link-arg=dynamic_lookup</code>, the other is to create a <code>.cargo/config</code> with the following content:</p>
<pre><code class="language-toml">[target.x86_64-apple-darwin]
rustflags = [
  &quot;-C&quot;, &quot;link-arg=-undefined&quot;,
  &quot;-C&quot;, &quot;link-arg=dynamic_lookup&quot;,
]
</code></pre>
<p>While developing, you can symlink (or copy) and rename the shared library from the target folder: On MacOS, rename <code>libstring_sum.dylib</code> to <code>string_sum.so</code>, on Windows <code>libstring_sum.dll</code> to <code>string_sum.pyd</code>, and on Linux <code>libstring_sum.so</code> to <code>string_sum.so</code>. Then open a Python shell in the same folder and you'll be able to <code>import string_sum</code>.</p>
<p>To build, test and publish your crate as a Python module, you can use <a href="https://github.com/PyO3/maturin">maturin</a> or <a href="https://github.com/PyO3/setuptools-rust">setuptools-rust</a>. You can find an example for setuptools-rust in <a href="https://github.com/PyO3/pyo3/tree/master/examples/word-count">examples/word-count</a>, while maturin should work on your crate without any configuration.</p>
<h2><a class="header" href="#using-python-from-rust" id="using-python-from-rust">Using Python from Rust</a></h2>
<p>If you want your Rust application to create a Python interpreter internally and
use it to run Python code, add <code>pyo3</code> to your <code>Cargo.toml</code> like this:</p>
<pre><code class="language-toml">[dependencies]
pyo3 = &quot;0.9.0&quot;
</code></pre>
<p>Example program displaying the value of <code>sys.version</code> and the current user name:</p>
<pre><pre class="playpen"><code class="language-rust">use pyo3::prelude::*;
use pyo3::types::IntoPyDict;

fn main() -&gt; Result&lt;(), ()&gt; {
    let gil = Python::acquire_gil();
    let py = gil.python();
    main_(py).map_err(|e| {
        // We can't display Python exceptions via std::fmt::Display,
        // so print the error here manually.
        e.print_and_set_sys_last_vars(py);
    })
}

fn main_(py: Python) -&gt; PyResult&lt;()&gt; {
    let sys = py.import(&quot;sys&quot;)?;
    let version: String = sys.get(&quot;version&quot;)?.extract()?;
    let locals = [(&quot;os&quot;, py.import(&quot;os&quot;)?)].into_py_dict(py);
    let code = &quot;os.getenv('USER') or os.getenv('USERNAME') or 'Unknown'&quot;;
    let user: String = py.eval(code, None, Some(&amp;locals))?.extract()?;
    println!(&quot;Hello {}, I'm Python {}&quot;, user, version);
    Ok(())
}
</code></pre></pre>
<p>Our guide has <a href="https://pyo3.rs/master/python_from_rust.html">a section</a> with lots of examples
about this topic.</p>
<h2><a class="header" href="#examples-and-tooling" id="examples-and-tooling">Examples and tooling</a></h2>
<ul>
<li><a href="https://github.com/PyO3/pyo3/tree/master/examples/word-count">examples/word-count</a> <em>Counting the occurrences of a word in a text file</em></li>
<li><a href="https://github.com/mre/hyperjson">hyperjson</a> <em>A hyper-fast Python module for reading/writing JSON data using Rust's serde-json</em></li>
<li><a href="https://github.com/PyO3/rust-numpy">rust-numpy</a> <em>Rust binding of NumPy C-API</em></li>
<li><a href="https://github.com/PyO3/setuptools-rust/tree/master/html-py-ever">html-py-ever</a> <em>Using <a href="https://github.com/servo/html5ever">html5ever</a> through <a href="https://github.com/kuchiki-rs/kuchiki">kuchiki</a> to speed up html parsing and css-selecting.</em></li>
<li><a href="https://github.com/PyO3/pyo3-built">pyo3-built</a> <em>Simple macro to expose metadata obtained with the <a href="https://crates.io/crates/built"><code>built</code></a> crate as a <a href="https://pyo3.github.io/pyo3/pyo3/struct.PyDict.html"><code>PyDict</code></a></em></li>
<li><a href="https://github.com/ManifoldFR/point-process-rust/tree/master/pylib">point-process</a> <em>High level API for pointprocesses as a Python library</em></li>
<li><a href="https://github.com/autopilot-rs/autopy">autopy</a> <em>A simple, cross-platform GUI automation library for Python and Rust.</em>
<ul>
<li>Contains an example of building wheels on TravisCI and appveyor using <a href="https://github.com/joerick/cibuildwheel">cibuildwheel</a></li>
</ul>
</li>
<li><a href="https://github.com/ijl/orjson">orjson</a>  <em>Fast Python JSON library</em></li>
<li><a href="https://github.com/dronesforwork/inline-python">inline-python</a> <em>Inline Python code directly in your Rust code</em></li>
<li><a href="https://github.com/kngwyu/rogue-gym">Rogue-Gym</a> <em>Customizable rogue-like game for AI experiments</em>
<ul>
<li>Contains an example of building wheels on Azure Pipelines</li>
</ul>
</li>
<li><a href="https://github.com/thedrow/fastuuid/">fastuuid</a> <em>Python bindings to Rust's UUID library</em></li>
<li><a href="https://github.com/wasmerio/python-ext-wasm">python-ext-wasm</a> <em>Python library to run WebAssembly binaries</em></li>
<li><a href="https://github.com/gperinazzo/dict-derive">dict-derive</a> <em>Derive FromPyObject to automatically transform Python dicts into Rust structs</em></li>
</ul>
<h1><a class="header" href="#python-modules" id="python-modules">Python Modules</a></h1>
<p>As shown in the Getting Started chapter, you can create a module as follows:</p>
<pre><pre class="playpen"><code class="language-rust">use pyo3::prelude::*;

// add bindings to the generated Python module
// N.B: &quot;rust2py&quot; must be the name of the `.so` or `.pyd` file.

/// This module is implemented in Rust.
#[pymodule]
fn rust2py(py: Python, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; {
    // PyO3 aware function. All of our Python interfaces could be declared in a separate module.
    // Note that the `#[pyfn()]` annotation automatically converts the arguments from
    // Python objects to Rust values, and the Rust return value back into a Python object.
    // The `_py` argument represents that we're holding the GIL.
    #[pyfn(m, &quot;sum_as_string&quot;)]
    fn sum_as_string_py(_py: Python, a: i64, b: i64) -&gt; PyResult&lt;String&gt; {
        let out = sum_as_string(a, b);
        Ok(out)
    }

    Ok(())
}

// logic implemented as a normal Rust function
fn sum_as_string(a: i64, b: i64) -&gt; String {
    format!(&quot;{}&quot;, a + b)
}

<span class="boring">fn main() {}
</span></code></pre></pre>
<p>The <code>#[pymodule]</code> procedural macro attribute takes care of exporting the initialization function of your module to Python. It can take as an argument the name of your module, which must be the name of the <code>.so</code> or <code>.pyd</code> file; the default is the Rust function's name.</p>
<p>To import the module, either copy the shared library as described in <a href="./get_started.html">Get Started</a> or use a tool, e.g. <code>maturin develop</code> with <a href="https://github.com/PyO3/maturin">maturin</a> or <code>python setup.py develop</code> with <a href="https://github.com/PyO3/setuptools-rust">setuptools-rust</a>.</p>
<h2><a class="header" href="#documentation" id="documentation">Documentation</a></h2>
<p>The <a href="https://doc.rust-lang.org/stable/book/first-edition/comments.html">Rust doc comments</a> of the module initialization function will be applied automatically as the Python docstring of your module.</p>
<pre><code class="language-python">import rust2py

print(rust2py.__doc__)
</code></pre>
<p>Which means that the above Python code will print <code>This module is implemented in Rust.</code>.</p>
<h2><a class="header" href="#modules-as-objects" id="modules-as-objects">Modules as objects</a></h2>
<p>In Python, modules are first class objects. This means that you can store them as values or add them to dicts or other modules:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;
use pyo3::{wrap_pyfunction, wrap_pymodule};
use pyo3::types::IntoPyDict;

#[pyfunction]
fn subfunction() -&gt; String {
    &quot;Subfunction&quot;.to_string()
}

#[pymodule]
fn submodule(_py: Python, module: &amp;PyModule) -&gt; PyResult&lt;()&gt; {
    module.add_wrapped(wrap_pyfunction!(subfunction))?;
    Ok(())
}

#[pymodule]
fn supermodule(_py: Python, module: &amp;PyModule) -&gt; PyResult&lt;()&gt; {
    module.add_wrapped(wrap_pymodule!(submodule))?;
    Ok(())
}

fn nested_call() {
    let gil = GILGuard::acquire();
    let py = gil.python();
    let supermodule = wrap_pymodule!(supermodule)(py);
    let ctx = [(&quot;supermodule&quot;, supermodule)].into_py_dict(py);

    py.run(&quot;assert supermodule.submodule.subfunction() == 'Subfunction'&quot;, None, Some(&amp;ctx)).unwrap();
}
<span class="boring">}
</span></code></pre></pre>
<p>This way, you can create a module hierarchy within a single extension module.</p>
<h1><a class="header" href="#python-functions" id="python-functions">Python Functions</a></h1>
<p>PyO3 supports two ways to define a free function in Python. Both require registering
the function to a <a href="./module.html">module</a>.</p>
<p>One way is defining the function in the module definition, annotated with <code>#[pyfn]</code>.</p>
<pre><pre class="playpen"><code class="language-rust">use pyo3::prelude::*;

#[pymodule]
fn rust2py(py: Python, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; {

    #[pyfn(m, &quot;sum_as_string&quot;)]
    fn sum_as_string_py(_py: Python, a:i64, b:i64) -&gt; PyResult&lt;String&gt; {
        Ok(format!(&quot;{}&quot;, a + b))
    }

    Ok(())
}

<span class="boring">fn main() {}
</span></code></pre></pre>
<p>The other is annotating a function with <code>#[pyfunction]</code> and then adding it
to the module using the <code>wrap_pyfunction!</code> macro.</p>
<pre><pre class="playpen"><code class="language-rust">use pyo3::prelude::*;
use pyo3::wrap_pyfunction;

#[pyfunction]
fn double(x: usize) -&gt; usize {
    x * 2
}

#[pymodule]
fn module_with_functions(py: Python, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; {
    m.add_wrapped(wrap_pyfunction!(double)).unwrap();

    Ok(())
}

<span class="boring">fn main() {}
</span></code></pre></pre>
<h2><a class="header" href="#argument-parsing" id="argument-parsing">Argument parsing</a></h2>
<p>Both the <code>#[pyfunction]</code> and <code>#[pyfn]</code> attributes support specifying details of
argument parsing.  The details are given in the section &quot;Method arguments&quot; in
the <a href="class.html">Classes</a> chapter.  Here is an example for a function that accepts
arbitrary keyword arguments (<code>**kwargs</code> in Python syntax) and returns the number
that was passed:</p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">extern crate pyo3;
</span>use pyo3::prelude::*;
use pyo3::wrap_pyfunction;
use pyo3::types::PyDict;

#[pyfunction(kwds=&quot;**&quot;)]
fn num_kwds(kwds: Option&lt;&amp;PyDict&gt;) -&gt; usize {
    kwds.map_or(0, |dict| dict.len())
}

#[pymodule]
fn module_with_functions(py: Python, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; {
    m.add_wrapped(wrap_pyfunction!(num_kwds)).unwrap();
    Ok(())
}

<span class="boring">fn main() {}
</span></code></pre></pre>
<h2><a class="header" href="#making-the-function-signature-available-to-python" id="making-the-function-signature-available-to-python">Making the function signature available to Python</a></h2>
<p>In order to make the function signature available to Python to be retrieved via
<code>inspect.signature</code>, use the <code>#[text_signature]</code> annotation as in the example
below. The <code>/</code> signifies the end of positional-only arguments. (This
is not a feature of this library in particular, but the general format used by
CPython for annotating signatures of built-in functions.)</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;

/// This function adds two unsigned 64-bit integers.
#[pyfunction]
#[text_signature = &quot;(a, b, /)&quot;]
fn add(a: u64, b: u64) -&gt; u64 {
    a + b
}
<span class="boring">}
</span></code></pre></pre>
<p>This also works for classes and methods:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;
use pyo3::types::PyType;

// it works even if the item is not documented:

#[pyclass]
#[text_signature = &quot;(c, d, /)&quot;]
struct MyClass {}

#[pymethods]
impl MyClass {
    // the signature for the constructor is attached
    // to the struct definition instead.
    #[new]
    fn new(c: i32, d: &amp;str) -&gt; Self {
        Self {}
    }
    // the self argument should be written $self
    #[text_signature = &quot;($self, e, f)&quot;]
    fn my_method(&amp;self, e: i32, f: i32) -&gt; i32 {
        e + f
    }
    #[classmethod]
    #[text_signature = &quot;(cls, e, f)&quot;]
    fn my_class_method(cls: &amp;PyType, e: i32, f: i32) -&gt; i32 {
        e + f
    }
    #[staticmethod]
    #[text_signature = &quot;(e, f)&quot;]
    fn my_static_method(e: i32, f: i32) -&gt; i32 {
        e + f
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#making-the-function-signature-available-to-python-old-method" id="making-the-function-signature-available-to-python-old-method">Making the function signature available to Python (old method)</a></h3>
<p>Alternatively, simply make sure the first line of your docstring is
formatted like in the following example. Please note that the newline after the
<code>--</code> is mandatory. The <code>/</code> signifies the end of positional-only arguments.</p>
<p><code>#[text_signature]</code> should be preferred, since it will override automatically
generated signatures when those are added in a future version of PyO3.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;

/// add(a, b, /)
/// --
///
/// This function adds two unsigned 64-bit integers.
#[pyfunction]
fn add(a: u64, b: u64) -&gt; u64 {
    a + b
}

// a function with a signature but without docs. Both blank lines after the `--` are mandatory.

/// sub(a, b, /)
/// --
///
///
#[pyfunction]
fn sub(a: u64, b: u64) -&gt; u64 {
    a - b
}
<span class="boring">}
</span></code></pre></pre>
<p>When annotated like this, signatures are also correctly displayed in IPython.</p>
<pre><code class="language-ignore">&gt;&gt;&gt; pyo3_test.add?
Signature: pyo3_test.add(a, b, /)
Docstring: This function adds two unsigned 64-bit integers.
Type:      builtin_function_or_method
</code></pre>
<h2><a class="header" href="#closures" id="closures">Closures</a></h2>
<p>Currently, there are no conversions between <code>Fn</code>s in Rust and callables in Python. This would definitely be possible and very useful, so contributions are welcome. In the meantime, you can do the following:</p>
<h3><a class="header" href="#calling-python-functions-in-rust" id="calling-python-functions-in-rust">Calling Python functions in Rust</a></h3>
<p>You can use <a href="https://docs.rs/pyo3/latest/pyo3/trait.ObjectProtocol.html#tymethod.is_callable"><code>ObjectProtocol::is_callable</code></a> to check if you have a callable object. <code>is_callable</code> will return <code>true</code> for functions (including lambdas), methods and objects with a <code>__call__</code> method. You can call the object with <a href="https://docs.rs/pyo3/latest/pyo3/trait.ObjectProtocol.html#tymethod.call"><code>ObjectProtocol::call</code></a> with the args as first parameter and the kwargs (or <code>None</code>) as second parameter. There are also <a href="https://docs.rs/pyo3/latest/pyo3/trait.ObjectProtocol.html#tymethod.call0"><code>ObjectProtocol::call0</code></a> with no args and <a href="https://docs.rs/pyo3/latest/pyo3/trait.ObjectProtocol.html#tymethod.call1"><code>ObjectProtocol::call1</code></a> with only positional args.</p>
<h3><a class="header" href="#calling-rust-functions-in-python" id="calling-rust-functions-in-python">Calling Rust functions in Python</a></h3>
<p>If you have a static function, you can expose it with <code>#[pyfunction]</code> and use <a href="https://docs.rs/pyo3/latest/pyo3/macro.wrap_pyfunction.html"><code>wrap_pyfunction!</code></a> to get the corresponding <a href="https://docs.rs/pyo3/latest/pyo3/struct.PyObject"><code>PyObject</code></a>. For dynamic functions, e.g. lambdas and functions that were passed as arguments, you must put them in some kind of owned container, e.g. a <code>Box</code>. (A long-term solution will be a special container similar to wasm-bindgen's <code>Closure</code>). You can then use a <code>#[pyclass]</code> struct with that container as a field as a way to pass the function over the FFI barrier. You can even make that class callable with <code>__call__</code> so it looks like a function in Python code.</p>
<h1><a class="header" href="#python-classes" id="python-classes">Python Classes</a></h1>
<h2><a class="header" href="#defining-a-new-class" id="defining-a-new-class">Defining a new class</a></h2>
<p>To define a custom Python class, a Rust struct needs to be annotated with the
<code>#[pyclass]</code> attribute.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span>#[pyclass]
struct MyClass {
    num: i32,
    debug: bool,
}
<span class="boring">}
</span></code></pre></pre>
<p>The above example generates implementations for <a href="https://docs.rs/pyo3/latest/pyo3/type_object/trait.PyTypeInfo.html"><code>PyTypeInfo</code></a>, <a href="https://docs.rs/pyo3/latest/pyo3/type_object/trait.PyTypeObject.html"><code>PyTypeObject</code></a>,
and <a href="https://pyo3.rs/master/doc/pyo3/pyclass/trait.PyClass.html"><code>PyClass</code></a> for <code>MyClass</code>.</p>
<p>Specifically, the following implementation is generated:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;

/// Class for demonstration
struct MyClass {
    num: i32,
    debug: bool,
}

impl pyo3::pyclass::PyClassAlloc for MyClass {}

unsafe impl pyo3::PyTypeInfo for MyClass {
    type Type = MyClass;
    type BaseType = PyAny;
    type BaseLayout = pyo3::pycell::PyCellBase&lt;PyAny&gt;;
    type Layout = PyCell&lt;Self&gt;;
    type Initializer = PyClassInitializer&lt;Self&gt;;
    type AsRefTarget = PyCell&lt;Self&gt;;

    const NAME: &amp;'static str = &quot;MyClass&quot;;
    const MODULE: Option&lt;&amp;'static str&gt; = None;
    const DESCRIPTION: &amp;'static str = &quot;Class for demonstration&quot;;
    const FLAGS: usize = 0;

    #[inline]
    fn type_object() -&gt; &amp;'static pyo3::ffi::PyTypeObject {
        use pyo3::type_object::LazyStaticType;
        static TYPE_OBJECT: LazyStaticType = LazyStaticType::new();
        TYPE_OBJECT.get_or_init::&lt;Self&gt;()
    }
}

impl pyo3::pyclass::PyClass for MyClass {
    type Dict = pyo3::pyclass_slots::PyClassDummySlot;
    type WeakRef = pyo3::pyclass_slots::PyClassDummySlot;
    type BaseNativeType = PyAny;
}

impl pyo3::IntoPy&lt;PyObject&gt; for MyClass {
    fn into_py(self, py: pyo3::Python) -&gt; pyo3::PyObject {
        pyo3::IntoPy::into_py(pyo3::Py::new(py, self).unwrap(), py)
    }
}

pub struct MyClassGeneratedPyo3Inventory {
    methods: &amp;'static [pyo3::class::PyMethodDefType],
}

impl pyo3::class::methods::PyMethodsInventory for MyClassGeneratedPyo3Inventory {
    fn new(methods: &amp;'static [pyo3::class::PyMethodDefType]) -&gt; Self {
        Self { methods }
    }

    fn get_methods(&amp;self) -&gt; &amp;'static [pyo3::class::PyMethodDefType] {
        self.methods
    }
}

impl pyo3::class::methods::PyMethodsInventoryDispatch for MyClass {
    type InventoryType = MyClassGeneratedPyo3Inventory;
}

pyo3::inventory::collect!(MyClassGeneratedPyo3Inventory);
<span class="boring">let gil = Python::acquire_gil();
</span><span class="boring">let py = gil.python();
</span><span class="boring">let cls = py.get_type::&lt;MyClass&gt;();
</span><span class="boring">pyo3::py_run!(py, cls, &quot;assert cls.__name__ == 'MyClass'&quot;)
</span><span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#adding-the-class-to-a-module" id="adding-the-class-to-a-module">Adding the class to a module</a></h2>
<p>Custom Python classes can then be added to a module using <code>add_class()</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">#[pyclass]
</span><span class="boring">struct MyClass {
</span><span class="boring">   num: i32,
</span><span class="boring">   debug: bool,
</span><span class="boring">}
</span>#[pymodule]
fn mymodule(_py: Python, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; {
    m.add_class::&lt;MyClass&gt;()?;
    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#pycell-and-interior-mutability" id="pycell-and-interior-mutability">PyCell and interior mutability</a></h2>
<p>You sometimes need to convert your <code>pyclass</code> into a Python object and access it
from Rust code (e.g., for testing it).
<a href="https://pyo3.rs/master/doc/pyo3/pycell/struct.PyCell.html"><code>PyCell</code></a> is the primary interface for that.</p>
<p><code>PyCell&lt;T: PyClass&gt;</code> is always allocated in the Python heap, so Rust doesn't have ownership of it.
In other words, Rust code can only extract a <code>&amp;PyCell&lt;T&gt;</code>, not a <code>PyCell&lt;T&gt;</code>.</p>
<p>Thus, to mutate data behind <code>&amp;PyCell</code> safely, PyO3 employs the
<a href="https://doc.rust-lang.org/book/ch15-05-interior-mutability.html">Interior Mutability Pattern</a>
like <a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html"><code>RefCell</code></a>.</p>
<p>Users who are familiar with <code>RefCell</code> can use <code>PyCell</code> just like <code>RefCell</code>.</p>
<p>For users who are not very familiar with <code>RefCell</code>, here is a reminder of Rust's rules of borrowing:</p>
<ul>
<li>At any given time, you can have either (but not both of) one mutable reference or any number of immutable references.</li>
<li>References must always be valid.</li>
</ul>
<p><code>PyCell</code>, like <code>RefCell</code>, ensures these borrowing rules by tracking references at runtime.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::types::PyDict;
</span>#[pyclass]
struct MyClass {
    #[pyo3(get)]
    num: i32,
    debug: bool,
}
let gil = Python::acquire_gil();
let py = gil.python();
let obj = PyCell::new(py, MyClass { num: 3, debug: true }).unwrap();
{
    let obj_ref = obj.borrow(); // Get PyRef
    assert_eq!(obj_ref.num, 3);
    // You cannot get PyRefMut unless all PyRefs are dropped
    assert!(obj.try_borrow_mut().is_err());
}
{
    let mut obj_mut = obj.borrow_mut(); // Get PyRefMut
    obj_mut.num = 5;
    // You cannot get any other refs until the PyRefMut is dropped
    assert!(obj.try_borrow().is_err());
    assert!(obj.try_borrow_mut().is_err());
}

// You can convert `&amp;PyCell` to a Python object
pyo3::py_run!(py, obj, &quot;assert obj.num == 5&quot;)
<span class="boring">}
</span></code></pre></pre>
<p><code>&amp;PyCell&lt;T&gt;</code> is bounded by the same lifetime as a <a href="https://docs.rs/pyo3/latest/pyo3/struct.GILGuard.html"><code>GILGuard</code></a>.
To make the object longer lived (for example, to store it in a struct on the
Rust side), you can use <code>Py&lt;T&gt;</code>, which stores an object longer than the GIL
lifetime, and therefore needs a <code>Python&lt;'_&gt;</code> token to access.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span>#[pyclass]
struct MyClass {
    num: i32,
}
fn return_myclass() -&gt; Py&lt;MyClass&gt; {
    let gil = Python::acquire_gil();
    let py = gil.python();
    Py::new(py, MyClass { num: 1 }).unwrap()
}
let gil = Python::acquire_gil();
let obj = return_myclass();
let cell = obj.as_ref(gil.python()); // AsPyRef::as_ref returns &amp;PyCell
let obj_ref = cell.borrow(); // Get PyRef&lt;T&gt;
assert_eq!(obj_ref.num, 1);
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#customizing-the-class" id="customizing-the-class">Customizing the class</a></h2>
<p>The <code>#[pyclass]</code> macro accepts the following parameters:</p>
<ul>
<li><code>name=XXX</code> - Set the class name shown in Python code. By default, the struct name is used as the class name.</li>
<li><code>freelist=XXX</code> - The <code>freelist</code> parameter adds support of free allocation list to custom class.
The performance improvement applies to types that are often created and deleted in a row,
so that they can benefit from a freelist. <code>XXX</code> is a number of items for the free list.</li>
<li><code>gc</code> - Classes with the <code>gc</code> parameter participate in Python garbage collection.
If a custom class contains references to other Python objects that can be collected, the <a href="https://docs.rs/pyo3/latest/pyo3/class/gc/trait.PyGCProtocol.html"><code>PyGCProtocol</code></a> trait has to be implemented.</li>
<li><code>weakref</code> - Adds support for Python weak references.</li>
<li><code>extends=BaseType</code> - Use a custom base class. The base <code>BaseType</code> must implement <code>PyTypeInfo</code>.</li>
<li><code>subclass</code> - Allows Python classes to inherit from this class.</li>
<li><code>dict</code> - Adds <code>__dict__</code> support, so that the instances of this type have a dictionary containing arbitrary instance variables.</li>
<li><code>module=&quot;XXX&quot;</code> - Set the name of the module the class will be shown as defined in. If not given, the class
will be a virtual member of the <code>builtins</code> module.</li>
</ul>
<h2><a class="header" href="#constructor" id="constructor">Constructor</a></h2>
<p>By default it is not possible to create an instance of a custom class from Python code.
To declare a constructor, you need to define a method and annotate it with the <code>#[new]</code>
attribute. Only Python's <code>__new__</code> method can be specified, <code>__init__</code> is not available.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span>#[pyclass]
struct MyClass {
    num: i32,
}

#[pymethods]
impl MyClass {
    #[new]
    fn new(num: i32) -&gt; Self {
        MyClass { num }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>If no method marked with <code>#[new]</code> is declared, object instances can only be
created from Rust, but not from Python.</p>
<p>For arguments, see the <code>Method arguments</code> section below.</p>
<h3><a class="header" href="#return-type" id="return-type">Return type</a></h3>
<p>Generally, <code>#[new]</code> method have to return <code>T: Into&lt;PyClassInitializer&lt;Self&gt;&gt;</code> or
<code>PyResult&lt;T&gt; where T: Into&lt;PyClassInitializer&lt;Self&gt;&gt;</code>.</p>
<p>For constructors that may fail, you should wrap the return type in a PyResult as well.
Consult the table below to determine which type your constructor should return:</p>
<table><thead><tr><th></th><th><strong>Cannot fail</strong></th><th><strong>May fail</strong></th></tr></thead><tbody>
<tr><td><strong>No inheritance</strong></td><td><code>T</code></td><td><code>PyResult&lt;T&gt;</code></td></tr>
<tr><td><strong>Inheritance(T Inherits U)</strong></td><td><code>(T, U)</code></td><td><code>PyResult&lt;(T, U)&gt;</code></td></tr>
<tr><td><strong>Inheritance(General Case)</strong></td><td><a href="https://pyo3.rs/master/doc/pyo3/pyclass_init/struct.PyClassInitializer.html"><code>PyClassInitializer&lt;T&gt;</code></a></td><td><code>PyResult&lt;PyClassInitializer&lt;T&gt;&gt;</code></td></tr>
</tbody></table>
<h2><a class="header" href="#inheritance" id="inheritance">Inheritance</a></h2>
<p>By default, <code>PyAny</code> is used as the base class. To override this default,
use the <code>extends</code> parameter for <code>pyclass</code> with the full path to the base class.</p>
<p>For convenience, <code>(T, U)</code> implements <code>Into&lt;PyClassInitializer&lt;T&gt;&gt;</code> where <code>U</code> is the
baseclass of <code>T</code>.
But for more deeply nested inheritance, you have to return <code>PyClassInitializer&lt;T&gt;</code>
explicitly.</p>
<p>To get a parent class from a child, use <a href="https://pyo3.rs/master/doc/pyo3/pycell/struct.PyRef.html"><code>PyRef</code></a> instead of <code>&amp;self</code> for methods,
or <a href="https://pyo3.rs/master/doc/pyo3/pycell/struct.PyRefMut.html"><code>PyRefMut</code></a> instead of <code>&amp;mut self</code>.
Then you can access a parent class by <code>self_.as_ref()</code> as <code>&amp;Self::BaseClass</code>,
or by <code>self_.into_super()</code> as <code>PyRef&lt;Self::BaseClass&gt;</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span>
#[pyclass]
struct BaseClass {
    val1: usize,
}

#[pymethods]
impl BaseClass {
    #[new]
    fn new() -&gt; Self {
        BaseClass { val1: 10 }
    }

    pub fn method(&amp;self) -&gt; PyResult&lt;usize&gt; {
        Ok(self.val1)
    }
}

#[pyclass(extends=BaseClass)]
struct SubClass {
    val2: usize,
}

#[pymethods]
impl SubClass {
    #[new]
    fn new() -&gt; (Self, BaseClass) {
        (SubClass { val2: 15 }, BaseClass::new())
    }

    fn method2(self_: PyRef&lt;Self&gt;) -&gt; PyResult&lt;usize&gt; {
        let super_ = self_.as_ref();  // Get &amp;BaseClass
        super_.method().map(|x| x * self_.val2)
    }
}

#[pyclass(extends=SubClass)]
struct SubSubClass {
    val3: usize,
}

#[pymethods]
impl SubSubClass {
    #[new]
    fn new() -&gt; PyClassInitializer&lt;Self&gt; {
        PyClassInitializer::from(SubClass::new())
            .add_subclass(SubSubClass{val3: 20})
    }

    fn method3(self_: PyRef&lt;Self&gt;) -&gt; PyResult&lt;usize&gt; {
        let v = self_.val3;
        let super_ = self_.into_super();  // Get PyRef&lt;SubClass&gt;
        SubClass::method2(super_).map(|x| x * v)
    }
}
<span class="boring">let gil = Python::acquire_gil();
</span><span class="boring">let py = gil.python();
</span><span class="boring">let subsub = pyo3::PyCell::new(py, SubSubClass::new()).unwrap();
</span><span class="boring">pyo3::py_run!(py, subsub, &quot;assert subsub.method3() == 3000&quot;)
</span><span class="boring">}
</span></code></pre></pre>
<p>You can also inherit native types such as <code>PyDict</code>, if they implement
<a href="https://pyo3.rs/master/doc/pyo3/type_object/trait.PySizedLayout.html"><code>PySizedLayout</code></a>.</p>
<p>However, because of some technical problems, we don't currently provide safe upcasting methods for types
that inherit native types. Even in such cases, you can unsafely get a base class by raw pointer conversion.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span>use pyo3::types::PyDict;
use pyo3::{AsPyPointer, PyNativeType};
use std::collections::HashMap;

#[pyclass(extends=PyDict)]
#[derive(Default)]
struct DictWithCounter {
    counter: HashMap&lt;String, usize&gt;,
}

#[pymethods]
impl DictWithCounter {
    #[new]
    fn new() -&gt; Self {
        Self::default()
    }
    fn set(mut self_: PyRefMut&lt;Self&gt;, key: String, value: &amp;PyAny) -&gt; PyResult&lt;()&gt; {
        self_.counter.entry(key.clone()).or_insert(0);
        let py = self_.py();
        let dict: &amp;PyDict = unsafe { py.from_borrowed_ptr_or_err(self_.as_ptr())? };
        dict.set_item(key, value)
    }
}
<span class="boring">let gil = Python::acquire_gil();
</span><span class="boring">let py = gil.python();
</span><span class="boring">let cnt = pyo3::PyCell::new(py, DictWithCounter::new()).unwrap();
</span><span class="boring">pyo3::py_run!(py, cnt, &quot;cnt.set('abc', 10); assert cnt['abc'] == 10&quot;)
</span><span class="boring">}
</span></code></pre></pre>
<p>If <code>SubClass</code> does not provide a baseclass initialization, the compilation fails.</p>
<pre><code class="language-compile_fail"># use pyo3::prelude::*;

#[pyclass]
struct BaseClass {
    val1: usize,
}

#[pyclass(extends=BaseClass)]
struct SubClass {
    val2: usize,
}

#[pymethods]
impl SubClass {
    #[new]
    fn new() -&gt; Self {
        SubClass { val2: 15 }
    }
}
</code></pre>
<h2><a class="header" href="#object-properties" id="object-properties">Object properties</a></h2>
<p>Property descriptor methods can be defined in a <code>#[pymethods]</code> <code>impl</code> block only and have to be
annotated with <code>#[getter]</code> and <code>#[setter]</code> attributes. For example:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span>#[pyclass]
struct MyClass {
    num: i32,
}

#[pymethods]
impl MyClass {
    #[getter]
    fn num(&amp;self) -&gt; PyResult&lt;i32&gt; {
        Ok(self.num)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>A getter or setter's function name is used as the property name by default. There are several
ways how to override the name.</p>
<p>If a function name starts with <code>get_</code> or <code>set_</code> for getter or setter respectively,
the descriptor name becomes the function name with this prefix removed. This is also useful in case of
Rust keywords like <code>type</code>
(<a href="https://doc.rust-lang.org/edition-guide/rust-2018/module-system/raw-identifiers.html">raw identifiers</a>
can be used since Rust 2018).</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">#[pyclass]
</span><span class="boring">struct MyClass {
</span><span class="boring">    num: i32,
</span><span class="boring">}
</span>#[pymethods]
impl MyClass {
    #[getter]
    fn get_num(&amp;self) -&gt; PyResult&lt;i32&gt; {
        Ok(self.num)
    }

    #[setter]
    fn set_num(&amp;mut self, value: i32) -&gt; PyResult&lt;()&gt; {
        self.num = value;
        Ok(())
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>In this case, a property <code>num</code> is defined and available from Python code as <code>self.num</code>.</p>
<p>Both the <code>#[getter]</code> and <code>#[setter]</code> attributes accept one parameter.
If this parameter is specified, it is used as the property name, i.e.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">#[pyclass]
</span><span class="boring">struct MyClass {
</span><span class="boring">   num: i32,
</span><span class="boring">}
</span>#[pymethods]
impl MyClass {
    #[getter(number)]
    fn num(&amp;self) -&gt; PyResult&lt;i32&gt; {
        Ok(self.num)
    }

    #[setter(number)]
    fn set_num(&amp;mut self, value: i32) -&gt; PyResult&lt;()&gt; {
        self.num = value;
        Ok(())
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>In this case, the property <code>number</code> is defined and available from Python code as <code>self.number</code>.</p>
<p>For simple cases where a member variable is just read and written with no side effects, you
can also declare getters and setters in your Rust struct field definition, for example:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span>#[pyclass]
struct MyClass {
    #[pyo3(get, set)]
    num: i32
}
<span class="boring">}
</span></code></pre></pre>
<p>Then it is available from Python code as <code>self.num</code>.</p>
<h2><a class="header" href="#instance-methods" id="instance-methods">Instance methods</a></h2>
<p>To define a Python compatible method, an <code>impl</code> block for your struct has to be annotated with the
<code>#[pymethods]</code> attribute. PyO3 generates Python compatible wrappers for all functions in this
block with some variations, like descriptors, class method static methods, etc.</p>
<p>Since Rust allows any number of <code>impl</code> blocks, you can easily split methods
between those accessible to Python (and Rust) and those accessible only to Rust.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">#[pyclass]
</span><span class="boring">struct MyClass {
</span><span class="boring">    num: i32,
</span><span class="boring">}
</span>#[pymethods]
impl MyClass {
    fn method1(&amp;self) -&gt; PyResult&lt;i32&gt; {
        Ok(10)
    }

    fn set_method(&amp;mut self, value: i32) -&gt; PyResult&lt;()&gt; {
        self.num = value;
        Ok(())
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Calls to these methods are protected by the GIL, so both <code>&amp;self</code> and <code>&amp;mut self</code> can be used.
The return type must be <code>PyResult&lt;T&gt;</code> or <code>T</code> for some <code>T</code> that implements <code>IntoPy&lt;PyObject&gt;</code>;
the latter is allowed if the method cannot raise Python exceptions.</p>
<p>A <code>Python</code> parameter can be specified as part of method signature, in this case the <code>py</code> argument
gets injected by the method wrapper, e.g.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">#[pyclass]
</span><span class="boring">struct MyClass {
</span><span class="boring">    num: i32,
</span><span class="boring">    debug: bool,
</span><span class="boring">}
</span>#[pymethods]
impl MyClass {
    fn method2(&amp;self, py: Python) -&gt; PyResult&lt;i32&gt; {
        Ok(10)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>From the Python perspective, the <code>method2</code> in this example does not accept any arguments.</p>
<h2><a class="header" href="#class-methods" id="class-methods">Class methods</a></h2>
<p>To create a class method for a custom class, the method needs to be annotated
with the <code>#[classmethod]</code> attribute.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::types::PyType;
</span><span class="boring">#[pyclass]
</span><span class="boring">struct MyClass {
</span><span class="boring">    num: i32,
</span><span class="boring">    debug: bool,
</span><span class="boring">}
</span>#[pymethods]
impl MyClass {
    #[classmethod]
    fn cls_method(cls: &amp;PyType) -&gt; PyResult&lt;i32&gt; {
        Ok(10)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Declares a class method callable from Python.</p>
<ul>
<li>The first parameter is the type object of the class on which the method is called.
This may be the type object of a derived class.</li>
<li>The first parameter implicitly has type <code>&amp;PyType</code>.</li>
<li>For details on <code>parameter-list</code>, see the documentation of <code>Method arguments</code> section.</li>
<li>The return type must be <code>PyResult&lt;T&gt;</code> or <code>T</code> for some <code>T</code> that implements <code>IntoPy&lt;PyObject&gt;</code>.</li>
</ul>
<h2><a class="header" href="#static-methods" id="static-methods">Static methods</a></h2>
<p>To create a static method for a custom class, the method needs to be annotated with the
<code>#[staticmethod]</code> attribute. The return type must be <code>T</code> or <code>PyResult&lt;T&gt;</code> for some <code>T</code> that implements
<code>IntoPy&lt;PyObject&gt;</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">#[pyclass]
</span><span class="boring">struct MyClass {
</span><span class="boring">    num: i32,
</span><span class="boring">    debug: bool,
</span><span class="boring">}
</span>#[pymethods]
impl MyClass {
    #[staticmethod]
    fn static_method(param1: i32, param2: &amp;str) -&gt; PyResult&lt;i32&gt; {
        Ok(10)
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#callable-objects" id="callable-objects">Callable objects</a></h2>
<p>To specify a custom <code>__call__</code> method for a custom class, the method needs to be annotated with
the <code>#[call]</code> attribute. Arguments of the method are specified as for instance methods.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span>use pyo3::types::PyTuple;
<span class="boring">#[pyclass]
</span><span class="boring">struct MyClass {
</span><span class="boring">    num: i32,
</span><span class="boring">    debug: bool,
</span><span class="boring">}
</span>#[pymethods]
impl MyClass {
    #[call]
    #[args(args=&quot;*&quot;)]
    fn __call__(&amp;self, args: &amp;PyTuple) -&gt; PyResult&lt;i32&gt; {
        println!(&quot;MyClass has been called&quot;);
        Ok(self.num)
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#method-arguments" id="method-arguments">Method arguments</a></h2>
<p>By default, PyO3 uses function signatures to determine which arguments are required. Then it scans
the incoming <code>args</code> and <code>kwargs</code> parameters. If it can not find all required
parameters, it raises a <code>TypeError</code> exception. It is possible to override the default behavior
with the <code>#[args(...)]</code> attribute. This attribute accepts a comma separated list of parameters in
the form of <code>attr_name=&quot;default value&quot;</code>. Each parameter has to match the method parameter by name.</p>
<p>Each parameter can be one of the following types:</p>
<ul>
<li><code>&quot;*&quot;</code>: var arguments separator, each parameter defined after <code>&quot;*&quot;</code> is a keyword-only parameter.
Corresponds to python's <code>def meth(*, arg1.., arg2=..)</code>.</li>
<li><code>args=&quot;*&quot;</code>: &quot;args&quot; is var args, corresponds to Python's <code>def meth(*args)</code>. Type of the <code>args</code>
parameter has to be <code>&amp;PyTuple</code>.</li>
<li><code>kwargs=&quot;**&quot;</code>: &quot;kwargs&quot; receives keyword arguments, corresponds to Python's <code>def meth(**kwargs)</code>.
The type of the <code>kwargs</code> parameter has to be <code>Option&lt;&amp;PyDict&gt;</code>.</li>
<li><code>arg=&quot;Value&quot;</code>: arguments with default value. Corresponds to Python's <code>def meth(arg=Value)</code>.
If the <code>arg</code> argument is defined after var arguments, it is treated as a keyword-only argument.
Note that <code>Value</code> has to be valid rust code, PyO3 just inserts it into the generated
code unmodified.</li>
</ul>
<p>Example:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span>use pyo3::types::{PyDict, PyTuple};
<span class="boring">
</span><span class="boring">#[pyclass]
</span><span class="boring">struct MyClass {
</span><span class="boring">    num: i32,
</span><span class="boring">    debug: bool,
</span><span class="boring">}
</span>#[pymethods]
impl MyClass {
    #[new]
    #[args(num = &quot;-1&quot;, debug = &quot;true&quot;)]
    fn new(num: i32, debug: bool) -&gt; Self {
        MyClass { num, debug }
    }

    #[args(
        num = &quot;10&quot;,
        debug = &quot;true&quot;,
        py_args = &quot;*&quot;,
        name = &quot;\&quot;Hello\&quot;&quot;,
        py_kwargs = &quot;**&quot;
    )]
    fn method(
        &amp;mut self,
        num: i32,
        debug: bool,
        name: &amp;str,
        py_args: &amp;PyTuple,
        py_kwargs: Option&lt;&amp;PyDict&gt;,
    ) -&gt; PyResult&lt;String&gt; {
        self.debug = debug;
        self.num = num;
        Ok(format!(
            &quot;py_args={:?}, py_kwargs={:?}, name={}, num={}, debug={}&quot;,
            py_args, py_kwargs, name, self.num, self.debug
        ))
    }

    fn make_change(&amp;mut self, num: i32, debug: bool) -&gt; PyResult&lt;String&gt; {
        self.num = num;
        self.debug = debug;
        Ok(format!(&quot;num={}, debug={}&quot;, self.num, self.debug))
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>N.B. the position of the <code>&quot;*&quot;</code> argument (if included) controls the system of handling positional and keyword arguments. In Python:</p>
<pre><code class="language-python">import mymodule

mc = mymodule.MyClass()
print(mc.method(44, False, &quot;World&quot;, 666, x=44, y=55))
print(mc.method(num=-1, name=&quot;World&quot;))
print(mc.make_change(44, False))
print(mc.make_change(debug=False, num=-1))
</code></pre>
<p>Produces output:</p>
<pre><code class="language-text">py_args=('World', 666), py_kwargs=Some({'x': 44, 'y': 55}), name=Hello, num=44, debug=false
py_args=(), py_kwargs=None, name=World, num=-1, debug=true
num=44, debug=false
num=-1, debug=false
</code></pre>
<h2><a class="header" href="#class-customizations" id="class-customizations">Class customizations</a></h2>
<p>Python's object model defines several protocols for different object behavior, like sequence,
mapping or number protocols. PyO3 defines separate traits for each of them. To provide specific
Python object behavior, you need to implement the specific trait for your struct. Important note,
each protocol implementation block has to be annotated with the <code>#[pyproto]</code> attribute.</p>
<h3><a class="header" href="#basic-object-customization" id="basic-object-customization">Basic object customization</a></h3>
<p>The <a href="https://docs.rs/pyo3/latest/pyo3/class/basic/trait.PyObjectProtocol.html"><code>PyObjectProtocol</code></a> trait provides several basic customizations.</p>
<h4><a class="header" href="#attribute-access" id="attribute-access">Attribute access</a></h4>
<p>To customize object attribute access, define the following methods:</p>
<ul>
<li><code>fn __getattr__(&amp;self, name: FromPyObject) -&gt; PyResult&lt;impl IntoPy&lt;PyObject&gt;&gt;</code></li>
<li><code>fn __setattr__(&amp;mut self, name: FromPyObject, value: FromPyObject) -&gt; PyResult&lt;()&gt;</code></li>
<li><code>fn __delattr__(&amp;mut self, name: FromPyObject) -&gt; PyResult&lt;()&gt;</code></li>
</ul>
<p>Each method corresponds to Python's <code>self.attr</code>, <code>self.attr = value</code> and <code>del self.attr</code> code.</p>
<h4><a class="header" href="#string-conversions" id="string-conversions">String Conversions</a></h4>
<ul>
<li>
<p><code>fn __repr__(&amp;self) -&gt; PyResult&lt;impl ToPyObject&lt;ObjectType=PyString&gt;&gt;</code></p>
</li>
<li>
<p><code>fn __str__(&amp;self) -&gt; PyResult&lt;impl ToPyObject&lt;ObjectType=PyString&gt;&gt;</code></p>
<p>Possible return types for <code>__str__</code> and <code>__repr__</code> are <code>PyResult&lt;String&gt;</code> or <code>PyResult&lt;PyString&gt;</code>.</p>
</li>
<li>
<p><code>fn __bytes__(&amp;self) -&gt; PyResult&lt;PyBytes&gt;</code></p>
<p>Provides the conversion to <code>bytes</code>.</p>
</li>
<li>
<p><code>fn __format__(&amp;self, format_spec: &amp;str) -&gt; PyResult&lt;impl ToPyObject&lt;ObjectType=PyString&gt;&gt;</code></p>
<p>Special method that is used by the <code>format()</code> builtin and the <code>str.format()</code> method.
Possible return types are <code>PyResult&lt;String&gt;</code> or <code>PyResult&lt;PyString&gt;</code>.</p>
</li>
</ul>
<h4><a class="header" href="#comparison-operators" id="comparison-operators">Comparison operators</a></h4>
<ul>
<li>
<p><code>fn __richcmp__(&amp;self, other: impl FromPyObject, op: CompareOp) -&gt; PyResult&lt;impl ToPyObject&gt;</code></p>
<p>Overloads Python comparison operations (<code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, and <code>&gt;=</code>).
The <code>op</code> argument indicates the comparison operation being performed.
The return type will normally be <code>PyResult&lt;bool&gt;</code>, but any Python object can be returned.
If <code>other</code> is not of the type specified in the signature, the generated code will
automatically <code>return NotImplemented</code>.</p>
</li>
<li>
<p><code>fn __hash__(&amp;self) -&gt; PyResult&lt;impl PrimInt&gt;</code></p>
<p>Objects that compare equal must have the same hash value.
The return type must be <code>PyResult&lt;T&gt;</code> where <code>T</code> is one of Rust's primitive integer types.</p>
</li>
</ul>
<h4><a class="header" href="#other-methods" id="other-methods">Other methods</a></h4>
<ul>
<li>
<p><code>fn __bool__(&amp;self) -&gt; PyResult&lt;bool&gt;</code></p>
<p>Determines the &quot;truthyness&quot; of the object.</p>
</li>
</ul>
<h3><a class="header" href="#garbage-collector-integration" id="garbage-collector-integration">Garbage Collector Integration</a></h3>
<p>If your type owns references to other Python objects, you will need to
integrate with Python's garbage collector so that the GC is aware of
those references.
To do this, implement the <a href="https://docs.rs/pyo3/latest/pyo3/class/gc/trait.PyGCProtocol.html"><code>PyGCProtocol</code></a> trait for your struct.
It includes two methods <code>__traverse__</code> and <code>__clear__</code>.
These correspond to the slots <code>tp_traverse</code> and <code>tp_clear</code> in the Python C API.
<code>__traverse__</code> must call <code>visit.call()</code> for each reference to another Python object.
<code>__clear__</code> must clear out any mutable references to other Python objects
(thus breaking reference cycles). Immutable references do not have to be cleared,
as every cycle must contain at least one mutable reference.
Example:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>extern crate pyo3;

use pyo3::prelude::*;
use pyo3::PyTraverseError;
use pyo3::gc::{PyGCProtocol, PyVisit};

#[pyclass]
struct ClassWithGCSupport {
    obj: Option&lt;PyObject&gt;,
}

#[pyproto]
impl PyGCProtocol for ClassWithGCSupport {
    fn __traverse__(&amp;self, visit: PyVisit) -&gt; Result&lt;(), PyTraverseError&gt; {
        if let Some(ref obj) = self.obj {
            visit.call(obj)?
        }
        Ok(())
    }

    fn __clear__(&amp;mut self) {
        if let Some(obj) = self.obj.take() {
            // Release reference, this decrements ref counter.
            let gil = GILGuard::acquire();
            let py = gil.python();
            py.release(obj);
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Special protocol trait implementations have to be annotated with the <code>#[pyproto]</code> attribute.</p>
<p>It is also possible to enable GC for custom classes using the <code>gc</code> parameter of the <code>pyclass</code> attribute.
i.e. <code>#[pyclass(gc)]</code>. In that case instances of custom class participate in Python garbage
collection, and it is possible to track them with <code>gc</code> module methods. When using the <code>gc</code> parameter,
it is <em>required</em> to implement the <code>PyGCProtocol</code> trait, failure to do so will result in an error
at compile time:</p>
<pre><code class="language-compile_fail">#[pyclass(gc)]
struct GCTracked {} // Fails because it does not implement PyGCProtocol
</code></pre>
<h3><a class="header" href="#iterator-types" id="iterator-types">Iterator Types</a></h3>
<p>Iterators can be defined using the
<a href="https://docs.rs/pyo3/latest/pyo3/class/iter/trait.PyIterProtocol.html"><code>PyIterProtocol</code></a> trait.
It includes two methods <code>__iter__</code> and <code>__next__</code>:</p>
<ul>
<li><code>fn __iter__(slf: PyRefMut&lt;Self&gt;) -&gt; PyResult&lt;impl IntoPy&lt;PyObject&gt;&gt;</code></li>
<li><code>fn __next__(slf: PyRefMut&lt;Self&gt;) -&gt; PyResult&lt;Option&lt;impl IntoPy&lt;PyObject&gt;&gt;&gt;</code></li>
</ul>
<p>Returning <code>Ok(None)</code> from <code>__next__</code> indicates that that there are no further items.</p>
<p>Example:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;
use pyo3::PyIterProtocol;

#[pyclass]
struct MyIterator {
    iter: Box&lt;Iterator&lt;Item = PyObject&gt; + Send&gt;,
}

#[pyproto]
impl PyIterProtocol for MyIterator {
    fn __iter__(mut slf: PyRefMut&lt;Self&gt;) -&gt; PyResult&lt;Py&lt;MyIterator&gt;&gt; {
        Ok(slf.into())
    }
    fn __next__(mut slf: PyRefMut&lt;Self&gt;) -&gt; PyResult&lt;Option&lt;PyObject&gt;&gt; {
        Ok(slf.iter.next())
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#how-methods-are-implemented" id="how-methods-are-implemented">How methods are implemented</a></h2>
<p>Users should be able to define a <code>#[pyclass]</code> with or without <code>#[pymethods]</code>, while PyO3 needs a
trait with a function that returns all methods. Since it's impossible to make the code generation in
pyclass dependent on whether there is an impl block, we'd need to implement the trait on
<code>#[pyclass]</code> and override the implementation in <code>#[pymethods]</code>, which is to the best of my knowledge
only possible with the specialization feature, which can't be used on stable.</p>
<p>To escape this we use <a href="https://github.com/dtolnay/inventory">inventory</a>, which allows us to collect <code>impl</code>s from arbitrary source code by exploiting some binary trick. See <a href="https://github.com/dtolnay/inventory#how-it-works">inventory: how it works</a> and <code>pyo3_derive_backend::py_class::impl_inventory</code> for more details.</p>
<h1><a class="header" href="#type-conversions" id="type-conversions">Type Conversions</a></h1>
<p>PyO3 provides some handy traits to convert between Python types and Rust types.</p>
<h2><a class="header" href="#extract-and-the-frompyobject-trait" id="extract-and-the-frompyobject-trait"><code>.extract()</code> and the <code>FromPyObject</code> trait</a></h2>
<p>The easiest way to convert a Python object to a Rust value is using
<code>.extract()</code>.  It returns a <code>PyResult</code> with a type error if the conversion
fails, so usually you will use something like</p>
<pre><code class="language-ignore">let v: Vec&lt;i32&gt; = obj.extract()?;
</code></pre>
<p>This method is available for many Python object types, and can produce a wide
variety of Rust types, which you can check out in the implementor list of
<a href="https://docs.rs/pyo3/latest/pyo3/types/trait.FromPyObject.html"><code>FromPyObject</code></a>.</p>
<p><a href="https://docs.rs/pyo3/latest/pyo3/types/trait.FromPyObject.html"><code>FromPyObject</code></a> is also implemented for your own Rust types wrapped as Python
objects (see <a href="class.html">the chapter about classes</a>).  There, in order to both be
able to operate on mutable references <em>and</em> satisfy Rust's rules of non-aliasing
mutable references, you have to extract the PyO3 reference wrappers <a href="https://pyo3.rs/master/doc/pyo3/pycell/struct.PyRef.html"><code>PyRef</code></a>
and <a href="https://pyo3.rs/master/doc/pyo3/pycell/struct.PyRefMut.html"><code>PyRefMut</code></a>.  They work like the reference wrappers of
<code>std::cell::RefCell</code> and ensure (at runtime) that Rust borrows are allowed.</p>
<h2><a class="header" href="#the-topyobject-trait" id="the-topyobject-trait">The <code>ToPyObject</code> trait</a></h2>
<p><a href="https://docs.rs/pyo3/latest/pyo3/trait.ToPyObject.html"><code>ToPyObject</code></a> is a conversion trait that allows various objects to be
converted into <a href="https://docs.rs/pyo3/latest/pyo3/struct.PyObject.html"><code>PyObject</code></a>. <code>IntoPy&lt;PyObject&gt;</code> serves the
same purpose, except that it consumes <code>self</code>.</p>
<h2><a class="header" href="#args-and-kwargs-for-python-object-calls" id="args-and-kwargs-for-python-object-calls"><code>*args</code> and <code>**kwargs</code> for Python object calls</a></h2>
<p>There are several ways how to pass positional and keyword arguments to a Python object call.
The <a href="https://docs.rs/pyo3/latest/pyo3/trait.ObjectProtocol.html"><code>ObjectProtocol</code></a> trait provides two methods:</p>
<ul>
<li><code>call</code> - call any callable Python object.</li>
<li><code>call_method</code> - call a specific method on the object, shorthand for <code>get_attr</code> then <code>call</code>.</li>
</ul>
<p>Both methods need <code>args</code> and <code>kwargs</code> arguments, but there are variants for less
complex calls, such as <code>call1</code> for only <code>args</code> and <code>call0</code> for no arguments at all.</p>
<pre><pre class="playpen"><code class="language-rust">use pyo3::prelude::*;
use pyo3::types::{PyDict, PyTuple};

struct SomeObject;
impl SomeObject {
    fn new(py: Python) -&gt; PyObject {
        PyDict::new(py).to_object(py)
    }
}

fn main() {
    let arg1 = &quot;arg1&quot;;
    let arg2 = &quot;arg2&quot;;
    let arg3 = &quot;arg3&quot;;

    let gil = Python::acquire_gil();
    let py = gil.python();

    let obj = SomeObject::new(py);

    // call object without empty arguments
    obj.call0(py);

    // call object with PyTuple
    let args = PyTuple::new(py, &amp;[arg1, arg2, arg3]);
    obj.call1(py, args);

    // pass arguments as rust tuple
    let args = (arg1, arg2, arg3);
    obj.call1(py, args);
}
</code></pre></pre>
<p><code>kwargs</code> can be <code>None</code> or <code>Some(&amp;PyDict)</code>. You can use the
<a href="https://docs.rs/pyo3/latest/pyo3/types/trait.IntoPyDict.html"><code>IntoPyDict</code></a> trait to convert other dict-like containers,
e.g. <code>HashMap</code> or <code>BTreeMap</code>, as well as tuples with up to 10 elements and
<code>Vec</code>s where each element is a two-element tuple.</p>
<pre><pre class="playpen"><code class="language-rust">use pyo3::prelude::*;
use pyo3::types::{IntoPyDict, PyDict};
use std::collections::HashMap;

struct SomeObject;

impl SomeObject {
    fn new(py: Python) -&gt; PyObject {
        PyDict::new(py).to_object(py)
    }
}

fn main() {
    let key1 = &quot;key1&quot;;
    let val1 = 1;
    let key2 = &quot;key2&quot;;
    let val2 = 2;

    let gil = Python::acquire_gil();
    let py = gil.python();

    let obj = SomeObject::new(py);

    // call object with PyDict
    let kwargs = [(key1, val1)].into_py_dict(py);
    obj.call(py, (), Some(kwargs));

    // pass arguments as Vec
    let kwargs = vec![(key1, val1), (key2, val2)];
    obj.call(py, (), Some(kwargs.into_py_dict(py)));

    // pass arguments as HashMap
    let mut kwargs = HashMap::&lt;&amp;str, i32&gt;::new();
    kwargs.insert(key1, 1);
    obj.call(py, (), Some(kwargs.into_py_dict(py)));
}
</code></pre></pre>
<h2><a class="header" href="#frompyt-and-intopyt" id="frompyt-and-intopyt"><code>FromPy&lt;T&gt;</code> and <code>IntoPy&lt;T&gt;</code></a></h2>
<p>Many conversions in PyO3 can't use <code>std::convert::From</code> because they need a GIL token.
The <a href="https://docs.rs/pyo3/latest/pyo3/trait.FromPy.html"><code>FromPy</code></a> trait offers an <code>from_py</code> method that works just like <code>from</code>, except for taking a <code>Python&lt;'_&gt;</code> argument.
I.e. <code>FromPy&lt;T&gt;</code> could be converting a Rust object into a Python object even though it is called <a href="https://docs.rs/pyo3/latest/pyo3/trait.FromPy.html"><code>FromPy</code></a> - it doesn't say anything about which side of the conversion is a Python object.</p>
<p>Just like <code>From&lt;T&gt;</code>, if you implement <code>FromPy&lt;T&gt;</code> you gain a blanket implementation of <a href="https://docs.rs/pyo3/latest/pyo3/trait.IntoPy.html"><code>IntoPy</code></a> for free.</p>
<p>Eventually, traits such as <a href="https://docs.rs/pyo3/latest/pyo3/trait.ToPyObject.html"><code>ToPyObject</code></a> will be replaced by this trait and a <a href="https://docs.rs/pyo3/latest/pyo3/trait.FromPy.html"><code>FromPy</code></a> trait will be added that will implement
<a href="https://docs.rs/pyo3/latest/pyo3/trait.IntoPy.html"><code>IntoPy</code></a>, just like with <code>From</code> and <code>Into</code>.</p>
<h1><a class="header" href="#python-exceptions" id="python-exceptions">Python Exceptions</a></h1>
<h2><a class="header" href="#defining-a-new-exception" id="defining-a-new-exception">Defining a new exception</a></h2>
<p>You can use the <a href="https://docs.rs/pyo3/latest/pyo3/macro.create_exception.html"><code>create_exception!</code></a> macro to define a new exception type:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use pyo3::create_exception;

create_exception!(module, MyError, pyo3::exceptions::Exception);
<span class="boring">}
</span></code></pre></pre>
<ul>
<li><code>module</code> is the name of the containing module.</li>
<li><code>MyError</code> is the name of the new exception type.</li>
</ul>
<p>For example:</p>
<pre><pre class="playpen"><code class="language-rust">use pyo3::prelude::*;
use pyo3::create_exception;
use pyo3::types::IntoPyDict;
use pyo3::exceptions::Exception;

create_exception!(mymodule, CustomError, Exception);

fn main() {
    let gil = Python::acquire_gil();
    let py = gil.python();
    let ctx = [(&quot;CustomError&quot;, py.get_type::&lt;CustomError&gt;())].into_py_dict(py);

    py.run(&quot;assert str(CustomError) == \&quot;&lt;class 'mymodule.CustomError'&gt;\&quot;&quot;, None, Some(&amp;ctx)).unwrap();
    py.run(&quot;assert CustomError('oops').args == ('oops',)&quot;, None, Some(&amp;ctx)).unwrap();
}
</code></pre></pre>
<h2><a class="header" href="#raising-an-exception" id="raising-an-exception">Raising an exception</a></h2>
<p>To raise an exception, first you need to obtain an exception type and construct a new <a href="https://docs.rs/pyo3/latest/pyo3/struct.PyErr.html"><code>PyErr</code></a>, then call the <a href="https://docs.rs/pyo3/latest/pyo3/struct.PyErr.html#method.restore"><code>PyErr::restore</code></a> method to write the exception back to the Python interpreter's global state.</p>
<pre><pre class="playpen"><code class="language-rust">use pyo3::{Python, PyErr};
use pyo3::exceptions;

fn main() {
    let gil = Python::acquire_gil();
    let py = gil.python();
    PyErr::new::&lt;exceptions::TypeError, _&gt;(&quot;Error&quot;).restore(py);
    assert!(PyErr::occurred(py));
    drop(PyErr::fetch(py));
}
</code></pre></pre>
<p>From <code>pyfunction</code>s and <code>pyclass</code> methods, returning an <code>Err(PyErr)</code> is enough;
PyO3 will handle restoring the exception on the Python interpreter side.</p>
<p>If you already have a Python exception instance, you can simply call <a href="https://docs.rs/pyo3/latest/pyo3/struct.PyErr.html#method.from_instance"><code>PyErr::from_instance</code></a>.</p>
<pre><code class="language-rust ignore">PyErr::from_instance(py, err).restore(py);
</code></pre>
<p>If a Rust type exists for the exception, then it is possible to use the <code>py_err</code> method.
For example, each standard exception defined in the <code>pyo3::exceptions</code> module
has a corresponding Rust type, exceptions defined by <a href="https://docs.rs/pyo3/latest/pyo3/macro.create_exception.html"><code>create_exception!</code></a> and <a href="https://docs.rs/pyo3/latest/pyo3/macro.import_exception.html"><code>import_exception!</code></a> macro
have Rust types as well.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::exceptions;
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">fn check_for_error() -&gt; bool {false}
</span>fn my_func(arg: PyObject) -&gt; PyResult&lt;()&gt; {
    if check_for_error() {
        Err(exceptions::ValueError::py_err(&quot;argument is wrong&quot;))
    } else {
        Ok(())
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#checking-exception-types" id="checking-exception-types">Checking exception types</a></h2>
<p>Python has an <a href="https://docs.python.org/3/library/functions.html#isinstance"><code>isinstance</code></a> method to check an object's type,
in PyO3 there is a <a href="https://docs.rs/pyo3/latest/pyo3/struct.Python.html#method.is_instance"><code>Python::is_instance</code></a> method which does the same thing.</p>
<pre><pre class="playpen"><code class="language-rust">use pyo3::Python;
use pyo3::types::{PyBool, PyList};

fn main() {
    let gil = Python::acquire_gil();
    let py = gil.python();
    assert!(py.is_instance::&lt;PyBool, _&gt;(PyBool::new(py, true)).unwrap());
    let list = PyList::new(py, &amp;[1, 2, 3, 4]);
    assert!(!py.is_instance::&lt;PyBool, _&gt;(list.as_ref()).unwrap());
    assert!(py.is_instance::&lt;PyList, _&gt;(list.as_ref()).unwrap());
}
</code></pre></pre>
<p><a href="https://docs.rs/pyo3/latest/pyo3/struct.Python.html#method.is_instance"><code>Python::is_instance</code></a> calls the underlying <a href="https://docs.rs/pyo3/latest/pyo3/types/struct.PyType.html#method.is_instance"><code>PyType::is_instance</code></a>
method to do the actual work.</p>
<p>To check the type of an exception, you can simply do:</p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">use pyo3::exceptions;
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">fn main() {
</span><span class="boring">let gil = Python::acquire_gil();
</span><span class="boring">let py = gil.python();
</span><span class="boring">let err = exceptions::TypeError::py_err(());
</span>err.is_instance::&lt;exceptions::TypeError&gt;(py);
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#handling-rust-errors" id="handling-rust-errors">Handling Rust errors</a></h2>
<p>The vast majority of operations in this library will return <a href="https://docs.rs/pyo3/latest/pyo3/prelude/type.PyResult.html"><code>PyResult&lt;T&gt;</code></a>,
which is an alias for the type <code>Result&lt;T, PyErr&gt;</code>.</p>
<p>A <a href="https://docs.rs/pyo3/latest/pyo3/struct.PyErr.html"><code>PyErr</code></a> represents a Python exception.
Errors within the PyO3 library are also exposed as Python exceptions.</p>
<p>The PyO3 library handles Python exceptions in two stages. During the first stage, a <a href="https://docs.rs/pyo3/latest/pyo3/struct.PyErr.html"><code>PyErr</code></a> instance is
created. At this stage, holding Python's GIL is not required. During the second stage, an actual Python
exception instance is created and set active in the Python interpreter.</p>
<p>In simple cases, for custom errors adding an implementation of <code>std::convert::From&lt;T&gt;</code> trait
for this custom error is enough. <code>PyErr::new</code> accepts an argument in the form
of <code>ToPyObject + 'static</code>. If the <code>'static</code> constraint can not be satisfied or
more complex arguments are required, the
<a href="https://docs.rs/pyo3/latest/pyo3/trait.PyErrArguments.html"><code>PyErrArguments</code></a>
trait can be implemented. In that case, actual exception argument creation is delayed
until a <code>Python</code> object is available.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::{exceptions, PyErr, PyResult};
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fmt;
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct CustomIOError;
</span><span class="boring">
</span><span class="boring">impl Error for CustomIOError {}
</span><span class="boring">
</span><span class="boring">impl fmt::Display for CustomIOError {
</span><span class="boring">    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
</span><span class="boring">        write!(f, &quot;Oh no!&quot;)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn bind(_addr: &amp;str) -&gt; Result&lt;(), CustomIOError&gt; {
</span><span class="boring">    Err(CustomIOError)
</span><span class="boring">}
</span>impl std::convert::From&lt;CustomIOError&gt; for PyErr {
    fn from(err: CustomIOError) -&gt; PyErr {
        exceptions::OSError::py_err(err.to_string())
    }
}

fn connect(s: String) -&gt; PyResult&lt;bool&gt; {
    bind(&quot;127.0.0.1:80&quot;)?;
    Ok(true)
}
<span class="boring">}
</span></code></pre></pre>
<p>The code snippet above will raise an <code>OSError</code> in Python if <code>bind()</code> returns a <code>CustomIOError</code>.</p>
<p>The <code>std::convert::From&lt;T&gt;</code> trait is implemented for most of the Rust standard library's error
types so the <code>?</code> operator can be used.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;

fn parse_int(s: String) -&gt; PyResult&lt;usize&gt; {
    Ok(s.parse::&lt;usize&gt;()?)
}
<span class="boring">}
</span></code></pre></pre>
<p>The code snippet above will raise a <code>ValueError</code> in Python if <code>String::parse()</code> returns an error.</p>
<h2><a class="header" href="#using-exceptions-defined-in-python-code" id="using-exceptions-defined-in-python-code">Using exceptions defined in Python code</a></h2>
<p>It is possible to use an exception defined in Python code as a native Rust type.
The <code>import_exception!</code> macro allows importing a specific exception class and defines a zero-sized Rust type
for that exception.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;
use pyo3::import_exception;

import_exception!(io, UnsupportedOperation);

fn tell(file: PyObject) -&gt; PyResult&lt;u64&gt; {
    use pyo3::exceptions::*;

    let gil = Python::acquire_gil();
    let py = gil.python();

    match file.call_method0(py, &quot;tell&quot;) {
        Err(_) =&gt; Err(UnsupportedOperation::py_err(&quot;not supported: tell&quot;)),
        Ok(x) =&gt; x.extract::&lt;u64&gt;(py),
    }
}

<span class="boring">}
</span></code></pre></pre>
<p><a href="https://docs.rs/pyo3/latest/pyo3/exceptions/index.html"><code>pyo3::exceptions</code></a>
defines exceptions for several standard library modules.</p>
<h1><a class="header" href="#calling-python-in-rust-code" id="calling-python-in-rust-code">Calling Python in Rust code</a></h1>
<p>These APIs work from Rust whenever you have a <code>Python</code> object handy, whether
PyO3 is built for an extension module or not.</p>
<h2><a class="header" href="#want-to-run-just-an-expression-then-use-eval" id="want-to-run-just-an-expression-then-use-eval">Want to run just an expression? Then use <code>eval</code>.</a></h2>
<p><a href="https://pyo3.rs/master/doc/pyo3/struct.Python.html#method.eval"><code>Python::eval</code></a> is
a method to execute a <a href="https://docs.python.org/3.7/reference/expressions.html">Python expression</a>
and return the evaluated value as a <code>&amp;PyAny</code> object.</p>
<pre><pre class="playpen"><code class="language-rust">use pyo3::prelude::*;
use pyo3::types::IntoPyDict;

fn main() -&gt; Result&lt;(), ()&gt; {
    let gil = Python::acquire_gil();
    let py = gil.python();
    let result = py.eval(&quot;[i * 10 for i in range(5)]&quot;, None, None).map_err(|e| {
        e.print_and_set_sys_last_vars(py);
    })?;
    let res: Vec&lt;i64&gt; = result.extract().unwrap();
    assert_eq!(res, vec![0, 10, 20, 30, 40]);
    Ok(())
}
</code></pre></pre>
<h2><a class="header" href="#want-to-run-statements-then-use-run" id="want-to-run-statements-then-use-run">Want to run statements? Then use <code>run</code>.</a></h2>
<p><a href="https://pyo3.rs/master/doc/pyo3/struct.Python.html#method.run"><code>Python::run</code></a> is a method to execute one or more
<a href="https://docs.python.org/3.7/reference/simple_stmts.html">Python statements</a>.
This method returns nothing (like any Python statement), but you can get
access to manipulated objects via the <code>locals</code> dict.</p>
<p>You can also use the <a href="https://pyo3.rs/master/doc/pyo3/macro.py_run.html"><code>py_run!</code></a> macro, which is a shorthand for <a href="https://pyo3.rs/master/doc/pyo3/struct.Python.html#method.run"><code>Python::run</code></a>.
Since <a href="https://pyo3.rs/master/doc/pyo3/macro.py_run.html"><code>py_run!</code></a> panics on exceptions, we recommend you use this macro only for
quickly testing your Python extensions.</p>
<pre><pre class="playpen"><code class="language-rust">use pyo3::prelude::*;
use pyo3::{PyCell, PyObjectProtocol, py_run};
<span class="boring"> fn main() {
</span>#[pyclass]
struct UserData {
    id: u32,
    name: String,
}
#[pymethods]
impl UserData {
    fn as_tuple(&amp;self) -&gt; (u32, String) {
        (self.id, self.name.clone())
    }
}
#[pyproto]
impl PyObjectProtocol for UserData {
    fn __repr__(&amp;self) -&gt; PyResult&lt;String&gt; {
        Ok(format!(&quot;User {}(id: {})&quot;, self.name, self.id))
    }
}
let gil = Python::acquire_gil();
let py = gil.python();
let userdata = UserData {
    id: 34,
    name: &quot;Yu&quot;.to_string(),
};
let userdata = PyCell::new(py, userdata).unwrap();
let userdata_as_tuple = (34, &quot;Yu&quot;);
py_run!(py, userdata userdata_as_tuple, r#&quot;
assert repr(userdata) == &quot;User Yu(id: 34)&quot;
assert userdata.as_tuple() == userdata_as_tuple
&quot;#);
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#you-have-a-python-file-or-python-function-then-use-pymodule" id="you-have-a-python-file-or-python-function-then-use-pymodule">You have a Python file or Python function? Then use <code>PyModule</code>.</a></h2>
<p><a href="https://pyo3.rs/master/doc/pyo3/types/struct.PyModule.html">PyModule</a> also can
execute Python code by calling its methods.</p>
<pre><pre class="playpen"><code class="language-rust">use pyo3::{prelude::*, types::{IntoPyDict, PyModule}};
<span class="boring"> fn main() -&gt; PyResult&lt;()&gt; {
</span>let gil = Python::acquire_gil();
let py = gil.python();
let activators = PyModule::from_code(py, r#&quot;
def relu(x):
    &quot;&quot;&quot;see https://en.wikipedia.org/wiki/Rectifier_(neural_networks)&quot;&quot;&quot;
    return max(0.0, x)

def leaky_relu(x, slope=0.01):
    return x if x &gt;= 0 else x * slope
&quot;#, &quot;activators.py&quot;, &quot;activators&quot;)?;

let relu_result: f64 = activators.call1(&quot;relu&quot;, (-1.0,))?.extract()?;
assert_eq!(relu_result, 0.0);

let kwargs = [(&quot;slope&quot;, 0.2)].into_py_dict(py);
let lrelu_result: f64 = activators
    .call(&quot;leaky_relu&quot;, (-1.0,), Some(kwargs))?
    .extract()?;
assert_eq!(lrelu_result, -0.2);
<span class="boring">Ok(()) }
</span></code></pre></pre>
<h1><a class="header" href="#gil-lifetimes-mutability-and-python-object-types" id="gil-lifetimes-mutability-and-python-object-types">GIL lifetimes, mutability and Python object types</a></h1>
<p>On first glance, PyO3 provides a huge number of different types that can be used
to wrap or refer to Python objects.  This page delves into the details and gives
an overview of their intended meaning, with examples when each type is best
used.</p>
<h2><a class="header" href="#mutability-and-rust-types" id="mutability-and-rust-types">Mutability and Rust types</a></h2>
<p>Since Python has no concept of ownership, and works solely with boxed objects,
any Python object can be referenced any number of times, and mutation is allowed
from any reference.</p>
<p>The situation is helped a little by the Global Interpreter Lock (GIL), which
ensures that only one thread can use the Python interpreter and its API at the
same time, while non-Python operations (system calls and extension code) can
unlock the GIL.  (See <a href="parallelism.html">the section on parallelism</a> for how to do
that in PyO3.)</p>
<p>In PyO3, holding the GIL is modeled by acquiring a token of the type
<code>Python&lt;'py&gt;</code>, which serves three purposes:</p>
<ul>
<li>It provides some global API for the Python interpreter, such as
<a href="https://docs.rs/pyo3/latest/pyo3/struct.Python.html#method.eval"><code>eval</code></a>.</li>
<li>It can be passed to functions that require a proof of holding the GIL,
such as <a href="https://docs.rs/pyo3/latest/pyo3/struct.PyObject.html#method.clone_ref"><code>PyObject::clone_ref</code></a>.</li>
<li>Its lifetime can be used to create Rust references that implicitly guarantee
holding the GIL, such as <a href="https://docs.rs/pyo3/latest/pyo3/types/struct.PyAny.html"><code>&amp;'py PyAny</code></a>.</li>
</ul>
<p>The latter two points are the reason why some APIs in PyO3 require the <code>py: Python</code> argument, while others don't.</p>
<p>The PyO3 API for Python objects is written such that instead of requiring a
mutable Rust reference for mutating operations such as
<a href="https://docs.rs/pyo3/latest/pyo3/types/struct.PyList.html#method.append"><code>PyList::append</code></a>, a shared reference (which, in turn, can only
be created through <code>Python&lt;'_&gt;</code> with a GIL lifetime) is sufficient.</p>
<p>However, Rust structs wrapped as Python objects (called <code>pyclass</code> types) usually
<em>do</em> need <code>&amp;mut</code> access.  Due to the GIL, PyO3 <em>can</em> guarantee thread-safe acces
to them, but it cannot statically guarantee uniqueness of <code>&amp;mut</code> references once
an object's ownership has been passed to the Python interpreter, ensuring
references is done at runtime using <code>PyCell</code>, a scheme very similar to
<code>std::cell::RefCell</code>.</p>
<h2><a class="header" href="#object-types" id="object-types">Object types</a></h2>
<h3><a class="header" href="#pyobject" id="pyobject"><code>PyObject</code></a></h3>
<p><strong>Represents:</strong> a GIL independent reference to a Python object of unspecified
type.</p>
<p><strong>Used:</strong> Whenever you want to carry around references to &quot;some&quot; Python object,
without caring about a GIL lifetime.  For example, storing Python object
references in a Rust struct that outlives the Python-Rust FFI boundary,
or returning objects from functions implemented in Rust back to Python.</p>
<p>Can be cloned using Python reference counts with <code>.clone_ref()</code>.</p>
<p><strong>Conversions:</strong></p>
<ul>
<li>To <code>&amp;PyAny</code>: <code>obj.as_ref(py)</code></li>
<li>To <code>Py&lt;ConcreteType&gt;</code>: <code>obj.as_ref(py).extract::&lt;Py&lt;ConcreteType&gt;&gt;</code></li>
<li>To <code>&amp;ConcreteType</code> (which must be a Python native type): <code>obj.cast_as(py)</code></li>
</ul>
<h3><a class="header" href="#pysometype" id="pysometype"><code>Py&lt;SomeType&gt;</code></a></h3>
<p><strong>Represents:</strong> a GIL independent reference to a Python object of known type.
This can be a Python native type (like <code>PyTuple</code>), or a <code>pyclass</code> type
implemented in Rust.</p>
<p><strong>Used:</strong> Like <code>PyObject</code>, but with a known inner type.</p>
<p><strong>Conversions:</strong></p>
<ul>
<li>To <code>PyObject</code>: <code>obj.to_object(py)</code></li>
<li>To <code>&amp;SomeType</code> or <code>&amp;PyCell&lt;SomeType&gt;</code>: <code>obj.as_ref(py)</code>.  For <code>pyclass</code> types
implemented in Rust, you get a <code>PyCell</code> (see below).  For Python native types,
mutating operations through PyO3's API don't require <code>&amp;mut</code> access.</li>
</ul>
<p><strong>Note:</strong> <code>PyObject</code> is semantically equivalent to <code>Py&lt;PyAny&gt;</code> and might be
merged with it in the future.</p>
<h3><a class="header" href="#pyany" id="pyany"><code>PyAny</code></a></h3>
<p><strong>Represents:</strong> a Python object of unspecified type, restricted to a GIL
lifetime.  Currently, <code>PyAny</code> can only ever occur as a reference, usually
<code>&amp;PyAny</code>.</p>
<p><strong>Used:</strong> Whenever you want to refer to some Python object only as long as
holding the GIL.  For example, intermediate values and arguments to
<code>pyfunction</code>s or <code>pymethod</code>s implemented in Rust where any type is allowed.</p>
<p><strong>Conversions:</strong></p>
<ul>
<li>To <code>PyObject</code>: <code>obj.to_object(py)</code></li>
</ul>
<h3><a class="header" href="#pytuple-pydict-and-many-more" id="pytuple-pydict-and-many-more"><code>PyTuple</code>, <code>PyDict</code>, and many more</a></h3>
<p><strong>Represents:</strong> a native Python object of known type, restricted to a GIL
lifetime just like <code>PyAny</code>.</p>
<p><strong>Used:</strong> Whenever you want to operate with native Python types while holding
the GIL.  Like <code>PyAny</code>, this is the most convenient form to use for function
arguments and intermediate values.</p>
<p><strong>Conversions:</strong></p>
<ul>
<li>To <code>PyAny</code>: <code>obj.as_ref()</code></li>
<li>To <code>Py&lt;T&gt;</code>: <code>Py::from(obj)</code></li>
</ul>
<h3><a class="header" href="#pycellsometype" id="pycellsometype"><code>PyCell&lt;SomeType&gt;</code></a></h3>
<p><strong>Represents:</strong> a reference to a Rust object (instance of <code>PyClass</code>) which is
wrapped in a Python object.  The cell part is an analog to stdlib's
<a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html"><code>RefCell</code></a> to allow access to <code>&amp;mut</code> references.</p>
<p><strong>Used:</strong> for accessing pure-Rust API of the instance (members and functions
taking <code>&amp;SomeType</code> or <code>&amp;mut SomeType</code>) while maintaining the aliasing rules of
Rust references.</p>
<p><strong>Conversions:</strong></p>
<ul>
<li>From <code>PyAny</code>: <code>.downcast()</code></li>
</ul>
<h3><a class="header" href="#pyrefsometype-and-pyrefmutsometype" id="pyrefsometype-and-pyrefmutsometype"><code>PyRef&lt;SomeType&gt;</code> and <code>PyRefMut&lt;SomeType&gt;</code></a></h3>
<p><strong>Represents:</strong> reference wrapper types employed by <code>PyCell</code> to keep track of
borrows, analog to <code>Ref</code> and <code>RefMut</code> used by <code>RefCell</code>.</p>
<p><strong>Used:</strong> while borrowing a <code>PyCell</code>.  They can also be used with <code>.extract()</code>
on types like <code>Py&lt;T&gt;</code> and <code>PyAny</code> to get a reference quickly.</p>
<h2><a class="header" href="#related-traits-and-types" id="related-traits-and-types">Related traits and types</a></h2>
<h3><a class="header" href="#pyclass" id="pyclass"><code>PyClass</code></a></h3>
<p>This trait marks structs defined in Rust that are also usable as Python classes,
usually defined using the <code>#[pyclass]</code> macro.</p>
<h3><a class="header" href="#pynativetype" id="pynativetype"><code>PyNativeType</code></a></h3>
<p>This trait marks structs that mirror native Python types, such as <code>PyList</code>.</p>
<h1><a class="header" href="#parallelism" id="parallelism">Parallelism</a></h1>
<p>CPython has the infamous GIL (Global Interpreter Lock), which prevents developers
from getting true parallelism when running pure Python code. While PyO3 needs to
hold the GIL by default when called from Python, in order to allow manipulation
of Python objects, you can release the GIL when executing Rust-only code to
achieve true parallelism.</p>
<p>The <a href="https://docs.rs/pyo3/latest/pyo3/struct.Python.html#method.allow_threads"><code>Python::allow_threads</code></a> method temporarily releases the GIL, thus allowing other Python threads to run.</p>
<pre><code class="language-rust ignore">impl Python {
    pub fn allow_threads&lt;T, F&gt;(self, f: F) -&gt; T where F: Send + FnOnce() -&gt; T {}
}
</code></pre>
<p>Let's take a look at our <a href="https://github.com/PyO3/pyo3/blob/master/examples/word-count/src/lib.rs">word-count</a> example,
where we have a <code>wc_parallel</code> function that utilizes the <a href="https://github.com/nikomatsakis/rayon">rayon</a> crate to count words in parallel.</p>
<pre><code class="language-rust ignore">fn wc_parallel(lines: &amp;str, search: &amp;str) -&gt; i32 {
    lines.par_lines()
         .map(|line| wc_line(line, search))
         .sum()
}
</code></pre>
<p>Then in the Python bridge, we have a function <code>search</code> exposed to the Python runtime which calls
<code>wc_parallel</code> inside a closure passed to <a href="https://docs.rs/pyo3/latest/pyo3/struct.Python.html#method.allow_threads"><code>Python::allow_threads</code></a> to enable true parallelism:</p>
<pre><code class="language-rust ignore">#[pymodule]
fn word_count(py: Python, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; {

    #[pyfn(m, &quot;search&quot;)]
    fn search(py: Python, path: String, search: String) -&gt; PyResult&lt;i32&gt; {
        let mut file = File::open(path)?;
        let mut contents = String::new();
        file.read_to_string(&amp;mut contents)?;

        let count = py.allow_threads(move || wc_parallel(&amp;contents, &amp;search));
        Ok(count)
    }

    Ok(())
}
</code></pre>
<h2><a class="header" href="#benchmark" id="benchmark">Benchmark</a></h2>
<p>Let's benchmark the <code>word-count</code> example to verify that we did unlock true parallelism with PyO3.
We are using <code>pytest-benchmark</code> to benchmark three word count functions:</p>
<ol>
<li><a href="https://github.com/PyO3/pyo3/blob/master/examples/word-count/word_count/__init__.py#L9">Pure Python version</a></li>
<li><a href="https://github.com/PyO3/pyo3/blob/master/examples/word-count/src/lib.rs#L64">Rust sequential version</a></li>
<li><a href="https://github.com/PyO3/pyo3/blob/master/examples/word-count/src/lib.rs#L54">Rust parallel version</a></li>
</ol>
<p>The benchmark script can be found <a href="https://github.com/PyO3/pyo3/blob/master/examples/word-count/tests/test_word_count.py">here</a>,
then we can run <code>pytest tests</code> to benchmark them.</p>
<p>On MacBook Pro (Retina, 15-inch, Mid 2015) the benchmark gives:</p>
<p><img src="https://user-images.githubusercontent.com/1556054/28604608-81bd6d22-71fe-11e7-8a2c-c3cf3bd0f622.png" alt="Benchmark Result" /></p>
<h1><a class="header" href="#debugging" id="debugging">Debugging</a></h1>
<h2><a class="header" href="#macros" id="macros">Macros</a></h2>
<p>PyO3's attributes (<code>#[pyclass]</code>, <code>#[pymodule]</code>, etc.) are <a href="https://doc.rust-lang.org/reference/procedural-macros.html">procedural macros</a>, which means that they rewrite the source of the annotated item. You can view the generated source with the following command, which also expands a few other things:</p>
<pre><code class="language-bash">cargo rustc --profile=check -- -Z unstable-options --pretty=expanded &gt; expanded.rs; rustfmt expanded.rs
</code></pre>
<p>(You might need to install <a href="https://github.com/rust-lang-nursery/rustfmt">rustfmt</a> if you don't already have it.)</p>
<p>You can also debug classic <code>!</code>-macros by adding <code>-Z trace-macros</code>:</p>
<pre><code class="language-bash">cargo rustc --profile=check -- -Z unstable-options --pretty=expanded -Z trace-macros &gt; expanded.rs; rustfmt expanded.rs
</code></pre>
<p>See <a href="https://github.com/dtolnay/cargo-expand">cargo expand</a> for a more elaborate version of those commands.</p>
<h2><a class="header" href="#running-with-valgrind" id="running-with-valgrind">Running with Valgrind</a></h2>
<p>Valgrind is a tool to detect memory management bugs such as memory leaks.</p>
<p>You first need to install a debug build of Python, otherwise Valgrind won't produce usable results. In Ubuntu there's e.g. a <code>python3-dbg</code> package.</p>
<p>Activate an environment with the debug interpreter and recompile. If you're on Linux, use <code>ldd</code> with the name of your binary and check that you're linking e.g. <code>libpython3.6dm.so.1.0</code> instead of <code>libpython3.6m.so.1.0</code>.</p>
<p><a href="https://raw.githubusercontent.com/python/cpython/master/Misc/valgrind-python.supp">Download the suppressions file for cpython</a>.</p>
<p>Run Valgrind with <code>valgrind --suppressions=valgrind-python.supp ./my-command --with-options</code></p>
<h2><a class="header" href="#getting-a-stacktrace" id="getting-a-stacktrace">Getting a stacktrace</a></h2>
<p>The best start to investigate a crash such as an segmentation fault is a backtrace.</p>
<ul>
<li>Link against a debug build of python as described in the previous chapter</li>
<li>Run <code>gdb &lt;my-binary&gt;</code></li>
<li>Enter <code>r</code> to run</li>
<li>After the crash occurred, enter <code>bt</code> or <code>bt full</code> to print the stacktrace</li>
</ul>
<h1><a class="header" href="#advanced-topics" id="advanced-topics">Advanced topics</a></h1>
<h2><a class="header" href="#ffi" id="ffi">FFI</a></h2>
<p>PyO3 exposes much of Python's C API through the <code>ffi</code> module.</p>
<p>The C API is naturally unsafe and requires you to manage reference counts, errors and specific invariants yourself. Please refer to the <a href="https://docs.python.org/3/c-api/">C API Reference Manual</a> and <a href="https://doc.rust-lang.org/nightly/nomicon/ffi.html">The Rustonomicon</a> before using any function from that API.</p>
<h2><a class="header" href="#testing" id="testing">Testing</a></h2>
<p>Currently, <a href="https://github.com/PyO3/pyo3/issues/341">#341</a> causes <code>cargo test</code> to fail with weird linking errors when the <code>extension-module</code> feature is activated. For now you can work around this by making the <code>extension-module</code> feature optional and running the tests with <code>cargo test --no-default-features</code>:</p>
<pre><code class="language-toml">[dependencies.pyo3]
version = &quot;0.8.1&quot;

[features]
extension-module = [&quot;pyo3/extension-module&quot;]
default = [&quot;extension-module&quot;]
</code></pre>
<h1><a class="header" href="#building-and-distribution" id="building-and-distribution">Building and Distribution</a></h1>
<h2><a class="header" href="#python-version" id="python-version">Python version</a></h2>
<p>PyO3 uses a build script to determine the Python version and set the correct linker arguments. By default it uses the <code>python3</code> executable. You can override the Python interpreter by setting <code>PYTHON_SYS_EXECUTABLE</code>, e.g., <code>PYTHON_SYS_EXECUTABLE=python3.6</code>.</p>
<h2><a class="header" href="#linking" id="linking">Linking</a></h2>
<p>Different linker arguments must be set for libraries/extension modules and binaries, which includes both standalone binaries and tests. (More specifically, binaries must be told where to find libpython and libraries must not link to libpython for <a href="https://www.python.org/dev/peps/pep-0513/">manylinux</a> compliance).</p>
<p>Since PyO3's build script can't know whether you're building a binary or a library, you have to activate the <code>extension-module</code> feature to get the build options for a library, or it'll default to binary.</p>
<p>If you have e.g. a library crate and a profiling crate alongside, you need to use optional features. E.g. you put the following in the library crate:</p>
<pre><code class="language-toml">[dependencies]
pyo3 = &quot;0.6&quot;

[lib]
name = &quot;hyperjson&quot;
crate-type = [&quot;rlib&quot;, &quot;cdylib&quot;]

[features]
default = [&quot;pyo3/extension-module&quot;]
</code></pre>
<p>And this in the profiling crate:</p>
<pre><code class="language-toml">[dependencies]
my_main_crate = { path = &quot;..&quot;, default-features = false }
pyo3 = &quot;0.6&quot;
</code></pre>
<p>On Linux/macOS you might have to change <code>LD_LIBRARY_PATH</code> to include libpython, while on windows you might need to set <code>LIB</code> to include <code>pythonxy.lib</code> (where x and y are major and minor version), which is normally either in the <code>libs</code> or <code>Lib</code> folder of a Python installation.</p>
<h2><a class="header" href="#distribution" id="distribution">Distribution</a></h2>
<p>There are two ways to distribute your module as a Python package: the old, <a href="https://github.com/PyO3/setuptools-rust">setuptools-rust</a>, and the new, <a href="https://github.com/pyo3/maturin">maturin</a>. setuptools-rust needs some configuration files (<code>setup.py</code>, <code>MANIFEST.in</code>, <code>build-wheels.sh</code>, etc.) and external tools (docker, twine). maturin doesn't need any configuration files. It can not yet build sdist though (<a href="https://github.com/PyO3/maturin/issues/2">pyo3/maturin#2</a>).</p>
<h2><a class="header" href="#cross-compiling" id="cross-compiling">Cross Compiling</a></h2>
<p>Cross compiling PyO3 modules is relatively straightforward and requires a few pieces of software:</p>
<ul>
<li>A toolchain for your target.</li>
<li>The appropriate options in your Cargo <code>.config</code> for the platform you're targeting and the toolchain you are using.</li>
<li>A Python interpreter that's already been compiled for your target.</li>
<li>The headers that match the above interpreter.</li>
</ul>
<p>See https://github.com/japaric/rust-cross for a primer on cross compiling Rust in general.</p>
<p>After you've obtained the above, you can build a cross compiled PyO3 module by setting a few extra environment variables:</p>
<ul>
<li><code>PYO3_CROSS_INCLUDE_DIR</code>: This variable must be set to the directory containing the headers for the target's Python interpreter.</li>
<li><code>PYO3_CROSS_LIB_DIR</code>: This variable must be set to the directory containing the target's libpython DSO.</li>
</ul>
<p>An example might look like the following (assuming your target's sysroot is at <code>/home/pyo3/cross/sysroot</code> and that your target is <code>armv7</code>):</p>
<pre><code class="language-sh">export PYO3_CROSS_INCLUDE_DIR=&quot;/home/pyo3/cross/sysroot/usr/include&quot;
export PYO3_CROSS_LIB_DIR=&quot;/home/pyo3/cross/sysroot/usr/lib&quot;

cargo build --target armv7-unknown-linux-gnueabihf
</code></pre>
<h1><a class="header" href="#pypy-support" id="pypy-support">PyPy Support</a></h1>
<p>Using PyPy is supported via cpyext.</p>
<p>Support is only provided for building Rust extension for code running under PyPy. This means that PyPy <strong>cannot</strong> be called from rust via cpyext. Note that there some differences in the ffi module between PyPy and CPython.</p>
<p>This is a limitation of cpyext and support for embedding cpyext is not planned.</p>
<p>Compilation against PyPy is done by exporting the <code>PYTHON_SYS_EXECUTABLE</code> to point to a PyPy binary or by compiling in a PyPy virtualenv.</p>
<p>For example, <code>PYTHON_SYS_EXECUTABLE=&quot;/path/to/pypy3&quot; /path/to/pypy3 setup.py install</code></p>
<h2><a class="header" href="#unsupported-features" id="unsupported-features">Unsupported features</a></h2>
<p>These are features currently supported by PyO3, but not yet implemented in cpyext.</p>
<ul>
<li>Complex number functions (<code>_Py_c_sum</code>, <code>_Py_c_sum</code> ..)</li>
<li>Conversion to rust's i128, u128 types.</li>
<li><code>PySequence_Count</code> (which is used to count number of element in array)</li>
<li><code>PyDict_MergeFromSeq2</code> (used in <code>PyDict::from_sequence</code>)</li>
</ul>
<h1><a class="header" href="#appendix-a-pyo3-and-rust-cpython" id="appendix-a-pyo3-and-rust-cpython">Appendix A: PyO3 and rust-cpython</a></h1>
<p>PyO3 began as fork of <a href="https://github.com/dgrunwald/rust-cpython">rust-cpython</a> when rust-cpython wasn't maintained. Over the time PyO3 has become fundamentally different from rust-cpython.</p>
<p>This chapter is based on the discussion in <a href="https://github.com/PyO3/pyo3/issues/55">PyO3/pyo3#55</a>.</p>
<h2><a class="header" href="#macros-1" id="macros-1">Macros</a></h2>
<p>While rust-cpython has a macro based dsl for declaring modules and classes, PyO3 uses proc macros and specialization. PyO3 also doesn't change your struct and functions so you can still use them as normal Rust functions. The disadvantage is that specialization currently only works on nightly.</p>
<p><strong>rust-cpython</strong></p>
<pre><code class="language-rust ignore">py_class!(class MyClass |py| {
    data number: i32;
    def __new__(_cls, arg: i32) -&gt; PyResult&lt;MyClass&gt; {
        MyClass::create_instance(py, arg)
    }
    def half(&amp;self) -&gt; PyResult&lt;i32&gt; {
        Ok(self.number(py) / 2)
    }
});
</code></pre>
<p><strong>pyo3</strong></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;

#[pyclass]
struct MyClass {
   num: u32,
}

#[pymethods]
impl MyClass {
    #[new]
    fn new(num: u32) -&gt; Self {
        MyClass { num }
    }

    fn half(&amp;self) -&gt; PyResult&lt;u32&gt; {
        Ok(self.num / 2)
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#ownership-and-lifetimes" id="ownership-and-lifetimes">Ownership and lifetimes</a></h2>
<p>All objects are owned by the PyO3 library and all APIs available with references, while in rust-cpython, you own python objects.</p>
<p>Here is an example of the PyList API:</p>
<p><strong>rust-cpython</strong></p>
<pre><code class="language-rust ignore">impl PyList {

   fn new(py: Python) -&gt; PyList {...}

   fn get_item(&amp;self, py: Python, index: isize) -&gt; PyObject {...}
}
</code></pre>
<p><strong>pyo3</strong></p>
<pre><code class="language-rust ignore">impl PyList {

   fn new(py: Python) -&gt; &amp;PyList {...}

   fn get_item(&amp;self, index: isize) -&gt; &amp;PyAny {...}
}
</code></pre>
<p>Because PyO3 allows only references to Python objects, all references have the GIL lifetime. So the owned Python object is not required, and it is safe to have functions like <code>fn py&lt;'p&gt;(&amp;'p self) -&gt; Python&lt;'p&gt; {}</code>.</p>
<h2><a class="header" href="#error-handling" id="error-handling">Error handling</a></h2>
<p>rust-cpython requires a <code>Python</code> parameter for constructing a <code>PyErr</code>, so error handling ergonomics is pretty bad. It is not possible to use <code>?</code> with Rust errors.</p>
<p>PyO3 on other hand does not require <code>Python</code> for constructing a <code>PyErr</code>, it is only required if you want to raise an exception in Python with the <code>PyErr::restore()</code> method. Due to various <code>std::convert::From&lt;E&gt; for PyErr</code> implementations for Rust standard error types <code>E</code>, propagating <code>?</code> is supported automatically.</p>
<h1><a class="header" href="#appendix-b-migrating-from-older-pyo3-versions" id="appendix-b-migrating-from-older-pyo3-versions">Appendix B: Migrating from older PyO3 versions</a></h1>
<p>This guide can help you upgrade code through breaking changes from one PyO3 version to the next. For a detailed list of all changes, see <a href="https://github.com/PyO3/pyo3/blob/master/CHANGELOG.md">CHANGELOG.md</a></p>
<h2><a class="header" href="#from-08-to-09" id="from-08-to-09">from 0.8.* to 0.9</a></h2>
<h3><a class="header" href="#new-interface" id="new-interface"><code>#[new]</code> interface</a></h3>
<p><a href="https://docs.rs/pyo3/0.8.5/pyo3/type_object/struct.PyRawObject.html"><code>PyRawObject</code></a>
is now removed and our syntax for constructors has changed.</p>
<p>Before:</p>
<pre><pre class="playpen"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>#[pyclass]
struct MyClass {}

#[pymethods]
impl MyClass {
   #[new]
   fn new(obj: &amp;PyRawObject) {
       obj.init(MyClass { })
   }
}
<span class="boring">}
</span></code></pre></pre>
<p>After:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span>#[pyclass]
struct MyClass {}

#[pymethods]
impl MyClass {
   #[new]
   fn new() -&gt; Self {
       MyClass {}
   }
}
<span class="boring">}
</span></code></pre></pre>
<p>Basically you can return <code>Self</code> or <code>Result&lt;Self&gt;</code> directly.
For more, see <a href="https://pyo3.rs/master/class.html#constructor">the constructor section</a> of this guide.</p>
<h3><a class="header" href="#pycell" id="pycell">PyCell</a></h3>
<p>PyO3 0.9 introduces <a href="https://pyo3.rs/master/doc/pyo3/pycell/struct.PyCell.html"><code>PyCell</code></a>, which is a <a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html"><code>RefCell</code></a>-like object wrapper
for ensuring Rust's rules regarding aliasing of references are upheld.
For more detail, see the
<a href="https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html#the-rules-of-references">Rust Book's section on Rust's rules of references</a></p>
<p>For <code>#[pymethods]</code> or <code>#[pyfunction]</code>s, your existing code should continue to work without any change.
Python exceptions will automatically be raised when your functions are used in a way which breaks Rust's
rules of references.</p>
<p>Here is an example.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span>#[pyclass]
struct Names {
    names: Vec&lt;String&gt;
}

#[pymethods]
impl Names {
    #[new]
    fn new() -&gt; Self {
        Names { names: vec![] }
    }
    fn merge(&amp;mut self, other: &amp;mut Names) {
        self.names.append(&amp;mut other.names)
    }
}
<span class="boring">let gil = Python::acquire_gil();
</span><span class="boring">let py = gil.python();
</span><span class="boring">let names = PyCell::new(py, Names::new()).unwrap();
</span><span class="boring">let borrow_mut_err = py.get_type::&lt;pyo3::pycell::PyBorrowMutError&gt;();
</span><span class="boring">pyo3::py_run!(py, names borrow_mut_err, r&quot;
</span><span class="boring">try:
</span><span class="boring">   names.merge(names)
</span><span class="boring">   assert False, 'Unreachable'
</span><span class="boring">except RuntimeError as e:
</span><span class="boring">   isinstance(e, borrow_mut_err)
</span><span class="boring">&quot;);
</span><span class="boring">}
</span></code></pre></pre>
<p><code>Names</code> has a <code>merge</code> method, which takes <code>&amp;mut self</code> and another argument of type <code>&amp;mut Self</code>.
Given this <code>#[pyclass]</code>, calling <code>names.merge(names)</code> in Python raises
a <a href="https://pyo3.rs/master/doc/pyo3/pycell/struct.PyBorrowMutError.html"><code>PyBorrowMutError</code></a> exception, since it requires two mutable borrows of <code>names</code>.</p>
<p>However, for <code>#[pyproto]</code> and some functions, you need to manually fix the code.</p>
<h4><a class="header" href="#object-creation" id="object-creation">Object creation</a></h4>
<p>In 0.8 object creation was done with <code>PyRef::new</code> and <code>PyRefMut::new</code>.
In 0.9 these have both been removed.
To upgrade code, please use
<a href="https://pyo3.rs/master/doc/pyo3/pycell/struct.PyCell.html#method.new"><code>PyCell::new</code></a> instead.
If you need <a href="https://pyo3.rs/master/doc/pyo3/pycell/struct.PyRef.html"><code>PyRef</code></a> or <a href="https://pyo3.rs/master/doc/pyo3/pycell/struct.PyRefMut.html"><code>PyRefMut</code></a>, just call <code>.borrow()</code> or <code>.borrow_mut()</code>
on the newly-created <code>PyCell</code>.</p>
<p>Before:</p>
<pre><pre class="playpen"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">#[pyclass]
</span><span class="boring">struct MyClass {}
</span>let gil = Python::acquire_gil();
let py = gil.python();
let obj_ref = PyRef::new(py, MyClass {}).unwrap();
<span class="boring">}
</span></code></pre></pre>
<p>After:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">#[pyclass]
</span><span class="boring">struct MyClass {}
</span>let gil = Python::acquire_gil();
let py = gil.python();
let obj = PyCell::new(py, MyClass {}).unwrap();
let obj_ref = obj.borrow();
<span class="boring">}
</span></code></pre></pre>
<h4><a class="header" href="#object-extraction" id="object-extraction">Object extraction</a></h4>
<p>For <code>PyClass</code> types <code>T</code>, <code>&amp;T</code> and <code>&amp;mut T</code> no longer have <a href="https://docs.rs/pyo3/latest/pyo3/conversion/trait.FromPyObject.html"><code>FromPyObject</code></a> implementations.
Instead you should extract <code>PyRef&lt;T&gt;</code> or <code>PyRefMut&lt;T&gt;</code>, respectively.
If <code>T</code> implements <code>Clone</code>, you can extract <code>T</code> itself.
In addition, you can also extract <code>&amp;PyCell&lt;T&gt;</code>, though you rarely need it.</p>
<p>Before:</p>
<pre><code class="language-ignore">let obj: &amp;PyAny = create_obj();
let obj_ref: &amp;MyClass = obj.extract().unwrap();
let obj_ref_mut: &amp;mut MyClass = obj.extract().unwrap();
</code></pre>
<p>After:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::types::IntoPyDict;
</span><span class="boring">#[pyclass] #[derive(Clone)] struct MyClass {}
</span><span class="boring">#[pymethods] impl MyClass { #[new]fn new() -&gt; Self { MyClass {} }}
</span><span class="boring">let gil = Python::acquire_gil();
</span><span class="boring">let py = gil.python();
</span><span class="boring">let typeobj = py.get_type::&lt;MyClass&gt;();
</span><span class="boring">let d = [(&quot;c&quot;, typeobj)].into_py_dict(py);
</span><span class="boring">let create_obj = || py.eval(&quot;c()&quot;, None, Some(d)).unwrap();
</span>let obj: &amp;PyAny = create_obj();
let obj_cell: &amp;PyCell&lt;MyClass&gt; = obj.extract().unwrap();
let obj_cloned: MyClass = obj.extract().unwrap(); // extracted by cloning the object
{
    let obj_ref: PyRef&lt;MyClass&gt; = obj.extract().unwrap();
    // we need to drop obj_ref before we can extract a PyRefMut due to Rust's rules of references
}
let obj_ref_mut: PyRefMut&lt;MyClass&gt; = obj.extract().unwrap();
<span class="boring">}
</span></code></pre></pre>
<h4><a class="header" href="#pyproto" id="pyproto"><code>#[pyproto]</code></a></h4>
<p>Most of the arguments to methods in <code>#[pyproto]</code> impls require a
<a href="https://docs.rs/pyo3/latest/pyo3/conversion/trait.FromPyObject.html"><code>FromPyObject</code></a> implementation.
So if your protocol methods take <code>&amp;T</code> or <code>&amp;mut T</code> (where <code>T: PyClass</code>),
please use <a href="https://pyo3.rs/master/doc/pyo3/pycell/struct.PyRef.html"><code>PyRef</code></a> or <a href="https://pyo3.rs/master/doc/pyo3/pycell/struct.PyRefMut.html"><code>PyRefMut</code></a> instead.</p>
<p>Before:</p>
<pre><pre class="playpen"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::class::PySequenceProtocol;
</span>#[pyclass]
struct ByteSequence {
    elements: Vec&lt;u8&gt;,
}
#[pyproto]
impl PySequenceProtocol for ByteSequence {
    fn __concat__(&amp;self, other: &amp;Self) -&gt; PyResult&lt;Self&gt; {
        let mut elements = self.elements.clone();
        elements.extend_from_slice(&amp;other.elements);
        Ok(Self { elements })
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>After:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::class::PySequenceProtocol;
</span>#[pyclass]
struct ByteSequence {
    elements: Vec&lt;u8&gt;,
}
#[pyproto]
impl PySequenceProtocol for ByteSequence {
    fn __concat__(&amp;self, other: PyRef&lt;'p, Self&gt;) -&gt; PyResult&lt;Self&gt; {
        let mut elements = self.elements.clone();
        elements.extend_from_slice(&amp;other.elements);
        Ok(Self { elements })
    }
}
<span class="boring">}
</span></code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
